# 内部类 

## 什么是内部类？

在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类，内部类本身就是类的一个属性，与其他属性定义方式一致

## 内部类的分类有哪些 

内部类可以分为四种：**成员内部类、局部内部类、匿名内部类和静态内部类。**

### 静态内部类 

定义在类内部的静态类，就是静态内部类

静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量

静态内部类的创建方式：new 外部类.静态内部类()

### 成员内部类 

定义在类内部，成员位置上的非静态类，就是成员内部类

成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有

成员内部类依赖于外部类的实例，它的创建方式为：外部类实例.new 内部类()

### 局部内部类

定义在方法中的内部类，就是局部内部类

定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法

局部内部类的创建方式，在对应方法内：new 内部类()

### 匿名内部类

匿名内部类就是没有名字的内部类，日常开发中使用的比较多。

除了没有名字，匿名内部类还有以下特点： 

- 匿名内部类必须继承一个抽象类或者实现一个接口
- 匿名内部类不能定义任何静态成员和静态方法
- 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final
- 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法

## 内部类的优点 

我们为什么要使用内部类呢？因为它有以下优点： 

- 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据
- 内部类不为同一包的其他类所见，具有很好的封装性
- 内部类有效实现了“多重继承”，优化 java 单继承的缺陷
- 匿名内部类可以很方便的定义回调

## 内部类有哪些应用场景 

1. 一些多算法场合 

2. 解决一些非面向对象的语句块

3. 适当使用内部类，使得代码更加灵活和富有扩展性

4. 当某个类除了它的外部类，不再被其他的类使用

## 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？ 

是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非 final 的局部变量就被销毁，而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错，加了 final， 可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题

对于一个使用 final 修饰的变量而言，如果定义该final变量时就指定初始值，而且这个初始值可以在编译时就确定下来，那么这个 final 变量将不再是一个变量，系统会将其变成“宏变量”处理，所有出现该变量的地方，系统将直接把它当成对应的值处理

执行“宏替换”的变量

final修饰符的一个重要用途就是定义“宏变量“，当定义final变量时就为该变量指定了初始值，而且该初始值可以在编译的时候就确定下来，那么这个final变量本质上就是一个”宏变量“，编译器会把程序中所用到该变量的地方直接替换成该变量的值，如果被赋的表达式只是基本的算术运算表达式或字符串连接运算，没有访问普通变量，调用方法，Java 编译器同样会将这种 final 变量当成”宏变量“处理

对于实例变量而言，可以在定义该变量时赋初始值之外，还可以在非静态初始化块、构造器中对它赋初始值，在这三个地方指定初始值的效果基本一样，但对于 final 实例变量而言，只有在定义该变量时指定初始值才会有”宏变量“的效果，在非静态初始化块、构造器中为 final实例变量指定初始值则不会有这种效果

对于普通类变量而言，在定义时指定初始值，在静态初始化块中赋初始值的效果基本一样但对于final类变量而言，只有在定义final类变量时指定初始值，系统才会对该final类变量执行”宏替换“