# 对象相等判断

## == 和 equals 的区别是什么

== : 它的作用是判断两个对象的地址是不是相等,即，判断两个对象是不是同一个对象(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址) 

equals() : 它的作用也是判断两个对象是否相等,但它一般有两种使用情况： 

- 情况1：类没有覆盖 equals() 方法，则通过 equals() 比较该类的两个对象时， 等价于通过“==”比较这两个对象
- 情况2：类覆盖了 equals() 方法，一般，我们都覆盖 equals() 方法来两个对象的内容相等，若它们的内容相等，则返回 true 


说明： 

- String中的equals方法是被重写过的，因为object的equals方法是比较的对象的 内存地址，而String的equals方法比较的是对象的值。 
- 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用，如果没有就在常量池中重新创建 一个 String 对象

## hashCode 与 equals (重要) 

HashSet 如何检查重复 

两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？ 

hashCode 和 equals方法的关系 

面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时 必须重写hashCode方法？”

### hashCode()介绍 

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整 数，这个哈希码的作用是确定该对象在哈希表中的索引位置，hashCode() 定义 在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。 

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出 对应的“值”

### 我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 

当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对 象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet 会假设对象没有重复出现，但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同，如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置，这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度

### hashCode()与equals()的相关规定 

如果两个对象相等，则 hashcode 一定也是相同的，两个对象相等，对两个对象分别调用 equals 方法都返回 true，反过来说，两个对象有相同的 hashcode 值，它们不一定是相等的，因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 

hashCode() 的默认行为是对堆上的对象产生独特值，如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

## 对象的相等与指向他们的引用相等，两者有什么不同？ 

对象的相等比的是内存中存放的内容是否相等，而引用相等比较的是他们指向的内存地址是否相等