# LockSupport与线程中断

## 线程中断机制

- 一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，所以，`Thread.stop`, `Thread.suspend`, `Thread.resume` 都已经被废弃了
- 在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作，因此，Java提供了一种用于停止线程的机制——中断
- 中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现
- 若要中断一个线程，你需要手动调用该线程的 `interrupt` 方法，该方法也仅仅是将线程对象的中断标识设成 true，接着你需要自己写代码不断地检测当前线程的标识位，如果为 true，表示别的线程要求这条线程中断，此时究竟该做什么需要你自己写代码实现
- 每个线程对象中都有一个标识，用于表示线程是否被中断，该标识位为 true 表示中断，为false表示未中断，通过调用线程对象的interrup t方法将该线程的标识位设为 true，可以在别的线程中调用，也可以在自己的线程中调用

### 中断API

| API                                 | 备注                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| public void interrupt()             | 实例方法 interrupt() 仅仅是设置线程的中断状态为true，不会停止线程 |
| public static boolean interrupted() | 返回当前线程的中断状态并将当前线程的中断状态设为false        |
| public boolean isInterrupted()      | 判断当前线程是否被中断（通过检查中断标志位）                 |

## 线程等待唤醒机制

### 线程等待和唤醒的方法

- 方式1：使用 Object 中的 wait() 方法让线程等待，使用 Object 中的 notify() 方法唤醒线程
  - wait 和 notify 方法必须要在同步块或者方法里面，且成对出现使用
  - 必须先 wait 后 notify
- 方式2：使用 JUC 包中 Condition 的 await() 方法让线程等待，使用 signal() 方法唤醒线程
  - Condtion 中的线程等待和唤醒方法之前，需要先获取锁
  - 必须先 await 后 signal
- 方式3：LockSupport 通过 park() 和 unpark(thread) 方法来实现阻塞和唤醒线程的操作
  - 无锁块要求
  - 无需遵循先阻塞再唤醒的步骤