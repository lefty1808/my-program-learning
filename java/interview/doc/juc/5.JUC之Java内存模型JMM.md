# JUC之Java内存模型JMM

JMM(Java内存模型 Java Memory Model，简称JMM) 本身是一种抽象的概念并不真实存在它仅仅描述的是一组约定或规范，通过这组规范定义了程序中(尤其是多线程)各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的

## 三大特性

### 可见性

是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更 ，JMM规定了所有的变量都存储在主内存中

Java中普通的共享变量不保证可见性，因为数据修改被写入内存的时机是不确定的，多线程并发下很可能出现"脏读"，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等 ）都必需在线程自己的工作内存中进行，而不能够直接读写主内存中的变量，不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成

### 原子性

指一个操作是不可中断的，即多线程环境下，操作不能被其他线程干扰

### 有序性

对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行

但为了提供性能，编译器和处理器通常会对指令序列进行重新排序

指令重排可以保证串行语义一致，但没有义务保证多线程间的语义也一致，即可能产生"脏读"，简单说，两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化

单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致

处理器在进行重排序时必须要考虑指令之间的数据依赖性

多线程环境中线程交替执行,由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测

## JMM 规范下的读取过程

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝到的线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成，其简要访问过程如下图

![jmm](https://blog.dreamly.fun/upload/2021/12/jmm-84a59ecfaa5340c1a4e91e62b0502566.jpeg)

**JMM定义了线程和主内存之间的抽象关系**

- 线程之间的共享变量存储在主内存中(从硬件角度来说就是内存条)
- 每个线程都有一个私有的本地工作内存，本地工作内存中存储了该线程用来读/写共享变量的副本(从硬件角度来说就是CPU的缓存，比如寄存器、L1、L2、L3缓存等)

**总结**

- 我们定义的所有共享变量都储存在物理主内存中
- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本(主内存中该变量的一份拷贝)
- 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存中读写(不能越级)
- 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行(同级不能相互访问)

## happens-before

在 JMM中，如果一个操作执行的结果需要对另一个操作可见性或者代码重排序，那么这两个操作之间必须存在happens-before关系

- 次序规则
  - 一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作
  - 前面一个操作把变量X赋值为1，那后面一个操作肯定能知道X已经变成了1
- 锁定规则
  - 一个 unLock 操作先行发生于后面((这里的“后面”是指时间上的先后))对同一个锁的 lock 操作
- volatile变量规则
  - 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作
  - 前面的写对后面的读是可见的，这里的“后面”同样是指时间上的先后
- 传递规则
  - 如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- 线程启动规则(Thread Start Rule)
  - Thread 对象的 start() 方法先行发生于此线程的每一个动作
- 线程中断规则(Thread Interruption Rule)
  - 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生
  - 可以通过 Thread.interrupted() 检测到是否发生中断
- 线程终止规则(Thread Termination Rule)
  - 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行
- 对象终结规则(Finalizer Rule)
  - 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize() 方法的开始