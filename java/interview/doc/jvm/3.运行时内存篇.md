# 运行时内存篇

## 说明

![jvm](https://blog.dreamly.fun/upload/2021/12/jvm-b3ee44c27e614b3186c1df2fd2caff66.png)

## 程序计数器

### 定义

为了保证程序(在操作系统中理解为进程）能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器

在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器 （PC）的内容即是从内存提取的第一条指令的地址，当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址

由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对 PC 加 1

当程序转移时，转移指令执行的最终结果就是要修改PC的值，此PC值就是转去的地址，以此实现转移，有些机器中也称RC为指令指针IP： (Instruction Pointer)

### 特征

JVM 中的程序计数寄存器 (Program Counter Register）中，Register 的命名源于CPu的奇存器，寄存器存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行

这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器 （或指令计数器）会更加贴切(也称为程序钩子），并且也不容易引起一些不必要的识会，JVM 中的 PC 寄存器是对物理PC寄存器的一种抽象模拟

它是一块很小的内存空间，几乎可以忽路不记。也是运行速度最快的存储区域，不会随着程序的运行需要更大的空间

在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致

它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域 

### **小结**

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器来完成

PC寄存器用来存储指向下一条指令的地址，即将要执行的指令代码，执行引擎的字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

## 虚拟机栈

### 栈存在GC吗

无GC，可能OOM

Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的，如果采用固定大小的 Java 虚拟机栈，那每一个线程的Java虛拟机栈容量可以在线程创建的时候独立选定，如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java虚拟机将会抛出一个`StackoverflowError`的异常

如果Java虛拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一𠆤 `OutOfMemoryError` 异常

### 如何设置栈的大小

- -Xss1024K
- 一般设置为512k-1024k，取决于操作系统
- 栈的大小直接决定了函数调用的最大深度和系统创建的线程数
- 在JDK 1.5 之前，默认的栈大小是256K
- 在JDK 1.5 之后，默认的栈大小是1024K

### 栈的单位-栈帧

每个线程都有自己的栈，栈中的数据都是以栈帧（stack flame）的形式存在

#### 方法与栈帧之间存在什么关系

- 在线程上正在执行的每个方法都各自对应一个栈帧 (Stack Frame)，栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
- 在一条活动线程中，一个时间点上，只会有一个活动的栈帧，即只有当前正在执行的方法的栈帧 （栈顶栈帧）是有效的，这个栈帧被称为当前栈帧 (Current Frame ），与当前栈帧相对应的方法就是当前方法(Current Method），定义这个方法的类就是当前类（CrrentCLass)，如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧
- 执行引擎运行的所有字节码指令只针对当前栈帧进行操作

#### 栈的FILO原理

JVM直接对 Java栈的操作只有两个

- 每个方法执行，伴随着进栈（入栈、压栈)
- 执行结束后的出栈工作

> 遵循“先进后出”/“后进先出”原则

- 不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧
- 如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧
- Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令,另外一种是拋出异常，不管使用哪种方式，都会导致栈帧被弹出

### 栈帧内部结构

每个栈帧中存储着如下的结构

- 局部变量表 ( Local Variables)
- 操作数栈 （Operand stack)
- 动态链接(Dynamic Linking) 
- 方法返回地址 (Return Address)

- 一些附加信息

#### 局部变量表

局部变量表也被称之为局部变量数组或本地变量表

定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型(8种）、对象引用 (reference)，以及returnAddress类型

局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的code属性的 `maximum local variables` 数据项中，在方法运行期间是不会改变局部变量表的大小的

方法嵌套调用的次数由栈的大小决定，一般来说，栈越大，方法嵌套调用次数越多，对一个函数而言，它的参数和局部变量越多，使得局部变量表膨账，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求，进而函数调用就会占用更多的栈空间导致其嵌套调用次数就会减少

局部变量表中的变量只在当前方法调用中有效，在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁

**局部变量表存在线程安全问题吗**

不存在，没有共享变量，都是线程独占

**关于 slot 的理解**

- 参数值的存放总是在局部变量数组的 index 为 0 开始，到数组长度-1的索引结束

- 局部变量表，最基本的存储单元是Slot（变量槽）

- 在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型)，64位的类型 (1ong和double)占用两个slot

  - byte、short、char 在存储前被转换为 int,  boolean 被转换为int，0 表示 false，非 0 表示true

  - long 和 double 则占据两个Slot

- JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值

- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上

- 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可(比如：访问long或double类型变量)

- 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在 index 为 0 的 slot 处，其余的参数按照参数表顺序继续排列

> slot可以重复利用的问题
>
> 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的

**静态变量与局部变量的对比**

- 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配
- 我们知道类变量表有两次初始化的机会，第一次是在 “准备阶段”，执行系统初始化对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值
- 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义局部变量则必须人为的初始化，否则无法使用

**局部变量表与GC ROOTS的关系**

局部变量表也是重要的垃圾回收根节点，只要被局部变量表中直接或者间接引用对象不会被回收

#### 操作数栈

- 我们说 Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈
- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-out）的操作数栈，也可以称之为表达式栈(Expression Stack)
- 操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 code 属性中，为maxstack 的值
- 栈中的任何一个元素都是可以任意的Java数据类型
  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度
- 操作数栈在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据，或是提取数据来完成一次数据访问
- 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈，使用它们后再把结果压入栈，比如：执行复制、交换、求和等操作
- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令
- 操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期问进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证

**栈顶缓存技术**

前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，Hotspot JVM的设计者们提出了栈顶缓存（TOS, Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率

#### 动态链接

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 (Dynamic Linking），比如 invokedynamic 指令，在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里

比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用

**为什么需要常量池**

提供一些符号和常量，便于指令的识别

**方法的调用**

静态链接与动态链接

#### 方法返回地址

- 存放调用该方法的PC寄存器的值
- 一个方法的结束，有2种方式
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置，方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址，而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息
- 当一个方法开始执行后，只有两种方式可以退出这个方法
  - 执行引擎遇到任意一个方法返回的字节码指令 (return），会有返回值传递给上层的方法调用者，简称正常完成出口
  - 一个方法在正常调用完成之后究竞需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定
- 在字节码指令中，返回指令包含 ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、 freturn、dreturn以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用
- 在方法执行的过程中遇到了异常 (Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称异常完成出口，方法执行过程中拋出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码
- 本质上，方法的退出就是当前栈帧出栈的过程，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去
- 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值

#### 附加信息

## 本地方法接口和本地方法栈

## 堆

## 方法区

## 直接内存

## StringTable

## 面试题