# 执行引擎篇

## 执行引擎是做什么的

- JVM 的主要任务是负责装裁字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息
- 那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是将宇节码指令解释/编译为对应平台上的本地机器指令才可以，简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者

## 执行引擎是怎么工作的

- 执行引擎在执行的过程中究竞需要执行什么样的字节码指令完全依赖于PC寄存器
- 每当执行完一项指令操作后，PC奇存器就会更新下一条需要被执行的指令地址
- 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息

## 代码编译和执行的过程

### 概念解释

- Java 语言的 “编译期” 其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫 “编译器的前端”
  更准确一些）把`.java`文件转变成 `.class`文件的过程
- 也可能是指虚拟机的后端运行期编译器（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程
- 还可能是指使用静态提前编译器（AOT 编译器，Ahead Of rime compiler）直接把 java文件编译成本地机器代码的过程
- 前端编译器：Sun 的 Javac、 Eclipse JDT 中的增量式编译器ECJ
- JIT 编译器：Hotspot VM 的 C1、C2 编译器
- AOT 编译器：GNU compiler for the Java （GCJ）
- Hotspot VM是目前市面上高性能虚拟机的代表作之一，它采用解释器与即时编译器并存的架构

### 解释器

JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法

### 现状

由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Per1、Ruby 等，但是在今天，基于解释器执行己经沦落为低效的代名词，并且时常被一些C/C++程序员所调侃

为了解决这个问题，JVN平台支持一种叫作即时编译的技术即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升

不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献

### 为什么说Java是半编译半解释语言

现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行

### JIT 编译器

JIT (Just In Time Compiler)编译器：就是虛拟机将源代码直接编译成和本地机器乎台相关的机器语言

**为什么还要保留解释器执行方式**

有些开发人员会感觉到诧异，既然HotSpot VM中己经内置了JIT编译器了，那么为什么还需要再使用解释器来 “拖累”程序的执行性能呢？比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行

首先要明确当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行，编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高

所以，尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译，对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点，在此模式下，当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间，随者时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率

同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的逃生门

**HotSpot VM 执行方式**

当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间，并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的宇节码编译为本地机器指令，以换取更高的程序执行效率

注意解释执行与编译执行在线上环境微妙的辦证关系，机器在热机状态可以承受的负载要大于冷机状态，如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死

在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1/8，曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布，如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVN均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1/2发布成功的服务器马上全部宕机，此故障说明了JIT 的存在（源自阿里）

**热点代码及探测方式**

是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，需要根据代在被调用执行的频率而定，关于那些需要被编译为本地代码的字节码，也被称之为 “热点代码”，JIT编译器在运行时会针对那些频繁被调用的 “热点代码”做出深度优化，将其直接编语为对应平台的本地机器指令，以此提升Java程序的执行性能

一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令，由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On Stack Replacement ）编译

一个方法宄竞要被调用多少次，或者一个循环体宄竞需要执行多少次循环才可以达到这个标准，必然需要一个明确的國值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行，这里主要依靠热点探测功能

目前Hotspot VM所采用的热点探测方式是基于计数器的热点探测

- 方法调用计数器
  - 这个计数器就用于统计方法被调用的次数，它的默认阈值在 Client 模式下是 1500次，在 server 模式下是 10000 次，超过这个國值，就会触发JIT编译
  - 这个國值可以通过虚拟机参数 -XX:CompileThreshold来人为设定
  - 一个方法被调用时，会先检查该方法是否存在被 JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行，如果不存在己被编译过的版本，则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果己超过國值，那么将会向即时编译器提交一个该方法的代码编译请求
- 回边计数器
  - 它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”(Back Edge)，显然，建立回边计数器统计的目的就是为了触发 OSR 编译 (On-Stack Replacement)
- 热度衰减
  - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数，当超过一定的时问限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减(counter Decay)，而这段时间就称为此方法统计的半衰局期 (counter Half tife Iime)
  - 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UsecounterDecar 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时问足够长，绝大部分方法都会被编译成本地代码
  - 另外，可以使用-XX:CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒

## HotSpot VM 执行方式

### 解释器与 JIT 并存架构

缺省情况 下HotSpot 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行，如下所示

-Xint：完全采用解释器模式执行程序

-Xcomp：完全采用即时编译器模式执行程序，如果即时编译出现问题，解释器会介入执行

-Xmixed：采用解释器 + 即时编译器的混合模式共同执行程序

### 2个编译器

在Hotspot VM中内嵌有两个JIT编译器，分别为Client Compiler 和 Server Compiler，但大多数情况下我们简称为C1编译器和C2编译器，开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示

- -client：指定 Java 虚拟机运行在Client模式下，并使用C1编译器
  - C1编译器会对字节码进行简单和可拿的优化，耗时短，以达到更快的编译速度
  - client 启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用于桌面应用程序
- -server：指定 Java 虚拟机运行在 Server 模式下，并使用C2编译器
  - C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高
  - server启动慢，占用内存多，执行效率高，适用于服务器端应用

> 由-XX:+RewriteFrequentPairs参数控制，client模式默认关闭，server模式默认开启

### 不同优化策略

- C1编译器上主要有方法内联，去虚拟化、冗余消除
  - 方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以跳转过程
  - 去虚拟化：对唯一的实现类进行内联
  - 冗余消除：在运行期间把一些不会执行的代码折叠掉
- C2 的优化主要是在全局层面，逃逸分析是优化的基础，基于逃逸分析在C2上有如下几种优化
  - 标量替换：用标量值代替聚合对象的属性值
  - 栈上分配：对于未逃逸的对象分配对象在栈而不是堆
  - 同步消除：清除同步操作，通常指 synchronized

**总结**

- 一般来讲，了IT编译出来的机器码性能比解释器高
- C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译

## 补充

### Graal 编译器

### AOT编译器

- jdk9 引入了 AOT 编译器 (静态提前编译器，Ahead Of Time Compiler)
- Java9引入了实验性 AOT 编译工具 jaotc，它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，存放至生成的动态共享库之中
- 所谓 AOT 编译，是与即时编译相对立的一个概念，我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程，而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程
- 最大好处：Java 虚拟机加载己经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少Java应用给人带来 “第一次运行慢”的不良体验
- 缺点
  - 破坏了 “java一次编译，到处运行〞，必须为每个不同硬件、oS编译对应的发行包
  - 降低了Java链接过程的动态性，加载的代码在编译期就必须全部己知
  - 还需要继续优化中，最初只支持Linux x64 java base

### 什么是动态编译

- 动态编译(compile during run-time），英文称Dynamic compilation，Just In Time也是这个意思
- Hotspot 对 bytecode 的编译不是在程序运行前编译的，而是在程序运行过程中编译的
- Hotspot里运行着一个监视器 (Profile Monitor），用来监视程序的运行状况
- Java字节码（class文件）是以解释的方式被加载到虚拟机中(默认启动时解释执行)，程序运行过程中，运用频率大，对程序的性能影响重要，对程序运行效率影响大的代码，称为热点（hotspot），Hotspot会把这些热点动态地编译成机器码 (native code)，同时对机器码进行优化，从而提高运行效率，对那些较少运行的代码，Hotspot就不会把他们编译
- Hotspot对字节码有三层处理
- 不编译(字节码加载到虛拟机中时的状态。也就是当虚拟机执行的时候再编译)
- 编译(把字节码编译成本地代码，虛拟机执行的时候己经编译好了，不要再编译了)
- 编译并优化（不但把字节码编译成本地代码，而且还进行了优化）
- 至于哪些程序不编译，哪些编译，哪些优化，则是由监视器 (Profile Monitor）决定

### 为什么不静态编译

- 动态编译器在许多方面比静态编译器优越，静态编译器通常很难准确预知程序运行过程中究竞什么部分最需要优化
- 函数调用都是很浪费系统时间的，因为有许多进栈出栈操作，因此有一种优化办法，就是把原来的函数调用，通过编译器的编译，改成非函数调用，把函数代码直接嵌到调用出，变成顺序执行
- 面向对象的语言支持多态，静态编译无效确定程序调用哪个方法，因为多态是在程序运行中确定调用哪个方法