#### 一，数据库设计规范

1. 所有数据库对象名称必须使用小写字母并使用下划线进行分割

2. 所有数据库对象名称禁止使用MySql保留关键字

3. 数据库对象的命名要能做到见名识意，并且最好不要超过32个字符

   ```xml
   用户数据库： synco_userdb
   用户账号表： user_account   
   ```

4. 临时库表必须以tmp为前缀并以日期为后缀

5. 备份库，备份表必须以bak为前缀并以日期为后缀

6. 所有存储相同数据的列名和列类型必须一致

7. Mysql在V5.5之前默认存储引擎是MyISAM；在此之后默认存储引擎是InnoDB

8. 所有的表必须使用Innodb存储引擎，Innodb支持事务，行级锁，更好的恢复性，高并发性能更好

9. 数据库和表的字符集统一使用utf8mb4 ，创建数据库时，为了获取更好的兼容性，应该总是使用 utf8mb4 而非 utf8. 对于 CHAR 类型数据，utf8mb4 会多消耗一些空间，根据 Mysql 官方建议，使用 VARCHAR 替代 CHAR。utf8mb4支持微信 Emoji 表情的存储。

10. 所有的表和字段都需要添加注释：使用comment从句添加表和列的备注

11. 单表数据量的大小，最好控制在500万行以内，可以用历史数据归档，分库分表来控制

12. 谨慎使用MySql分区表

13. 尽量做到冷热数据分离，减少表的宽度，减少磁盘IO，保存热数据的内存缓存命中率，利用更有效的利用缓存，避免读入无用的冷数据，经常使用的列放在一个表中

14. 禁止在表中建立预留字段

    预留字段的命名很难达到见名识意

    预留字段无法确认存储的数据类型

    对预留字段的类型的修改，会对表进行锁定

15. 禁止在数据库中存储图片，文件等二进制数据

16. 禁止在线上做数据库压力测试

17. 禁止从开发环境，测试环境直连生产环境数据库

#### 二，索引设计规范

1. 限制每张表的索引数量，建议单张表索引不超过5个

   禁止给表中的每一列都建立单独的索引

   每个Innodb表必须有一个主键，不能使用更新频繁的列作为主键

   不使用多列主键

   不使用UUID，MD5，HASH，字符串作为主键

   **最好使用自增ID值作为主键**

2. 常见索引列建议：select，update，delete语句中的where从句中的列

   包含在order by，group by，distinct中的字段

   多表join的关联列

3. 如何选择索引列的顺序

   区分度最高的列放在联合索引的最左侧

   尽量把字段长度小的列放在联合索引的最左侧

   使用最频繁的列放在联合索引的左侧

4. 避免建立冗余索引和重复索引

5. 对于频繁的查询优先考虑使用覆盖索引，避免Innodb表进行索引的二次查找

6. 尽量避免使用外键

   不建议使用外键约束，但是一定在表与表之间的关联键上建立索引

   外键可用于保证数据的参照完整性，但建议在业务端实现

   外键会影响父表和子表的写操作从而降低性能

#### 三，数据库字段设计规范

1. 优先选择符合存储需要的最小的数据类型，例如：将字符串转换成数字类型存储

   ```mysql
   INET_ATON（'255.255.255.255'）=4294967295
   INET_NTOA（4294967295）= '255.255.255.255'
   ```

   无符号相对与有符号可以多出一倍的存储空间，所以对于非负数据采用无符号整形进行存储

   ```mysql
   SIGNED INT           -2147483648~2147483647
   
   UNSIGNED INT         0~4294967295
   
   VARCHAR（N）中代表的是字符数，而不是字节数
   ```

   使用UTF8存储汉字Varchar（255）=765个字节

   过大的长度会消耗更多的内存

2. 避免使用TEXT，BLOB数据类型，如果一定要用，建议把BLOB或是TEXT列分离到单独的扩展表中

   TEXT或者BLOB类型只能使用前缀索引

3. 避免使用ENUM数据类型

   修改ENUM值需要使用ALTER语句

   ENUM类型的ORDER BY操作效率低，需要额外操作

   禁止使用数值作为ENUM的枚举值

4. 尽可能把所有列定义为NOT NULL

   索引NULL列需要额外的控件来保存，所以要占用更多的空间

   进行比较和计算时要对NULL值做特别的处理

5. 禁止使用字符串存储日期型的数据

   缺点1：无法用日期函数进行计算和比较

   缺点2：用字符串存储日期要占用更多的空间

6. 使用TIMESTAMP或DATETIME类型存储时间

   TIMESTAMP：1970-01-01 00:00:01~2038-01-19 03:14:17

   TIMESTAMP占用4字节和INT相同，但比INT可读性高

   超过TIMESTAMP取值范围的使用DATETIME类型

7. 同财务相关的金额类数据，必须使用Decimal类型

   Decimal类型为精准浮点数，在计算时不会丢失精度

   占用空间由定义的宽度决定

   可用于存储比bigint更大的整数数据

#### 四，数据库SQL开发规范

1. 建议使用预编译语句进行数据库操作

   只传参数，比传递SQL语句更有效

   相同语句可以一次解析，多次使用，提高处理效率

2. 避免数据类型的隐式转换

   隐式转换会导致索引失效

   ```
   select name,phone from customer where id = '111'
   ```

3. 充分利用表上已经存在的索引

   避免使用双%号的查询条件，如：a like '%123%'

   一个SQL只能利用到符合索引的一列进行范围查询

   使用left join 或 not exists来优化not in操作

4. 禁止跨库查询

   为数据库迁移和分库分表留出余地

   降低业务耦合度

   避免权限过大而产生的安全风险

5. 禁止使用SELECT * 必须使用SELECT<字段列表>查询

   消耗更多的CPU和IO以及网络带宽资源

   无法使用覆盖索引

   不使用SELECT * 可减少表结构变更带来的影响

6. 禁止使用不含字段列表的INSERT语句

7. 避免使用子查询，可以把子查询优化为join操作

   子查询的结果集无法使用索引

   子查询会产生临时表操作，如果子查询数据量大则严重影响效率

   消耗过多的CPU及IO资源

8. 避免使用JOIN关联太多的表

   每Join一个表会多占用一部分的内存（join_buffer_size）

   会产生临时表操作，影响查询效率

   MySql最多允许关联61个表，建议不超过5个

9. 减少同数据库的交互次数

   数据库更适合处理批量操作

   合并多个相同的操作到一起，可以提高处理效率

10. 使用in代替or

    in的值不要超过500个

    in操作可以有效的利用索引

11. 禁止使用 orser by rand() 进行随机排序

    随机排序会把表中所有符合条件的数据装载到内存中进行排序，消耗大量的CPU和内存资源

    推荐在程序中获取一个随机值，然后从数据库获取数据的方式

12. WHERE从句中禁止对列进行函数转换和计算

    对列进行函数转换或者计算会导致无法使用索引：

    ```mysql
    where date(createtime)='20160901'
    ```

    可以换成：

    ```mysql
    where createtime >= '20160901'
    and createtime < '20160902'
    ```

13. 在明显不会有重复值时使用UNION ALL而不是UNION

    UNION会把所有数据放到临时表中再进行去重操作

    UNION ALl不会再对结果集进行去重操作

14. 拆分复杂的大SQL为多个小SQL

    对与MySql，一个SQL只能使用一个CPU进行计算

    SQL拆分后可以通过并行执行来提高处理效率

#### 五，数据库操作行为规范

1. 超100万行的批量写操作，要分批多次进行操作

   对于查询，要尽可能的一次查询，就不要分批查询了

   大批量写操作可能会造成严重的主从延迟

   binlog日志为row格式时会产生大量的日志

   避免产生大事务操作

2. 对于大表使用pt-online-schema-change修改表结构

   避免大表修改产生的主从延迟

   避免在对表字段进行修改时进行锁表

3. 禁止为程序使用的账号赋予super权限

   当达到最大连接数限制时，还允许1个有super权限的用户连接

   super权限只能留给DBA处理问题的账号使用

4. 对于程序连接数据库账号，遵循权限最小原则

   程序使用数据库账号只能在一个DB下使用，不准跨库

   程序使用的账号原则上不准有drop权限

#### 六，第三范式（3NF）

​        一个表中的列与其他列之间既不包含部分函数依赖关系，也不包含函数传递关系，那么这个表的设计就符合第三范式。

#### Mysql支持的存储引擎

```mysql
show engines;
```

| MyISAM   
| InnoDB        
| MRG_MYISAM       
| MEMORY             
| BLACKHOLE                 
| CSV              
| ARCHIVE          
| PERFORMANCE_SCHEMA
| FEDERATED   

| 区别   | MyISAM                                 | InnoDB                                           |
| ------ | -------------------------------------- | ------------------------------------------------ |
| 主外键 | 不支持                                 | 支持                                             |
| 事务   | 不支持                                 | 支持                                             |
| 锁     | 表锁，当操作表数据时，锁住的是，整个表 | 行锁，当操作表数据时锁住的是一行数据，适合高并发 |
| 缓存   | 缓存的只有数据，没有索引               | 缓存的数据+索引                                  |

#### 三大范式

1NF:
确保每一列的原子性
2NF:
确保非主键字段都需要与主键有关联
3NF:
确保非主键字段都与主键有直接联系

#### 索引

索引（Index）是帮助MySQL高效获取数据的数据结构。可以得出索引的本质：索引是数据结构

我们平常所说的索引，如果没有特别指明，都是指B树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚合索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引（hash index）等。

查看表的索引

```mysql
show index from `table_name`;
```



##### 索引的优势：

- 类似大学图书馆建立书目索引，提高数据检索的效率，降低数据库的IO成本

- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

##### 索引的劣势：

- 虽然索引大大提高了查询速度(读)，同时却会降低更新表的速度（写），如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字端，都会调整因为更新所带来的键值变化后的索引信息

##### 创建索引

这是最基本的索引，它没有任何限制。它有以下几种创建方式：

```
CREATE INDEX indexName ON mytable(username(length)); 
```

如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

##### 修改表结构(添加索引)

```
ALTER table tableName ADD INDEX indexName(columnName)
```

##### 创建表的时候直接指定

```
CREATE TABLE mytable(  
 
ID INT NOT NULL,   
 
username VARCHAR(16) NOT NULL,  
 
INDEX [indexName] (username(length))  
 
);  
```

##### 使用ALTER 命令添加和删除索引

添加一个主键索引，这意味着索引值必须是唯一的，且不能为NULL。 

```mysql
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)
```

添加一个唯一索引，（除了NULL外，NULL可能会出现多次）。 

```mysql
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)
```

添加普通索引，索引值可出现多次 

```mysql
ALTER TABLE tbl_name ADD INDEX index_name (column_list)
```

下面的语句指定了索引为 FULLTEXT ，用于全文索引。 

```mysql
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) 
```

##### 使用 ALTER 命令添加和删除主键

主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：

```
mysql> ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;
mysql> ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
```

你也可以使用 ALTER 命令删除主键：

```
mysql> ALTER TABLE testalter_tbl DROP PRIMARY KEY;
```

删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。

##### 使用EXPLAIN关键字对SQL语句进行执行计划的分析

**字段的解释分析：**

**id**

select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，分3种：

id相同，执行顺序由上至下

id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

id相同，不同 同时存在：id值越大，优先级越高，越先执行，如果id一致，按照顺序，从上向下依次执行

**select_type**

查询的类型，主要用于区别普通查询、联合查询、子查询等的复杂查询

1. **SIMPLE** 简单的select查询，查询中不包含子查询或者UNION

2. 查询中若包含复杂的子部分，最外层查询则被标记为**：PRIMARY** 

3. 在SELECT或WHERE列表中包含了子查询，该子查询被标记为：**SUBQUERY**

4. 在FROM列表中包含的子查询被标记为：DERIVED（衍生）用来表示包含在from子句中的子查询的select，mysql会递归执行并将结果放到一个临时表中。服务器内部称为"派生表"，因为该临时表是从子查询中派生出来的
5. 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED
6. 从UNION表获取结果的SELECT被标记为：UNION RESULT
7. SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。
8. DEPENDENT意味着select依赖于外层查询中发现的数据。
9. UNCACHEABLE意味着select中的某些 特性阻止结果被缓存于一个item_cache中。

**type**

显示查询使用了何种类型 好->差 system>const>eq_ref>ref>range>index>ALL

**system** : 表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，可以忽略。

**const** :表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只配置一行数据，所以很快；如将主键置于where列表中，MySQL就能将该查询转换为一个常量。

**eq_ref** :唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描

**ref**: 非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体

**range**: 只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引；一般就是在你的 where 语句中出现了 between、<、>、in 等查询;这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。

**index**:  Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）

**all**: Full Table Scan，将遍历全表以找到匹配的行

备注：一般来说，得保证查询至少达到range级别，最好能达到ref。

### MySql5.7设置默认时区（东八区）

查看mysql系统时间。和当前时间做对比

select now();             

设置时区更改为东八区         

set global time_zone = '+8:00';  

刷新权限

flush privileges;              

#### MySql设置自增初始值

```mysql
alter table table_name auto_increment=10011;
```

注意n只能大于已有的auto_increment的整数值,小于的值无效.