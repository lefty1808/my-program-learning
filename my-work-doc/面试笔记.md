## 网络

## 数据库

### 索引

#### 结构

- 建立二叉查找树进行二分查找
- 建立 B-Tree 结构进行查找
- 建立 B+-Tree 结构进行查找
- 建立 Hash 结构进行查找

#### B-Tree

-  根节点至少包括2个孩子
- 树中每个节点最多含有 m 个孩子（m>=2）
- 除根节点和叶节点外，其他每个节点至少有 ceil(m/2)个孩子
- 所有叶子节点都位于同一层

#### B+Tree为什么更适合做存储索引

- 磁盘读写代价更低
- 查询效率更加稳定
- 更有利于对数据库的扫描

#### B+-Tree

B+树是B树的变体，其定义基本与B树相同

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针 P[i]，指向关键字值 [K[i], K[i+1]]的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子节点

#### Hash索引

缺点

- 仅仅满足 "=", "IN", 不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
- BitMap 位图索引

#### 密集索引与稀疏索引

- 密集索引文件中的每个搜索码值都对应一个索引值
- 稀疏索引文件只为索引码的某些值建立索引项
- InnoDB必须有且仅有一个密集索引
  - 若一个主键被定义，那么该主键作为密集索引
  - 若没有主键被定义，该表的第一个唯一非空索引作为密集索引
  - 若不满足以上条件，InnoDB内部会生成一个隐藏主键作为密集索引
  - 非主键索引存储相关键位和其对应的主键值，包含两次查询

#### 总结

- 为什么要使用索引
- 什么样的信息能成为索引
- 索引的数据结构
- 密集索引和稀疏索引的区别

#### 开启慢日志

```mysql
set global slow_query_log = on
set global long_query_time = 1
```

#### 开启SQL分析

- 在SQL语句前加 `explain`
- type：找到需要行的方式，index和all表示本次查询是全表扫描
- extra
  - Using filesort：表示MySQl对结果使用一个外部索引，而不是从表里按索引次序读到相关内容，可能在内存或者磁盘上进行排序，MySQL无法利用索引完成的排序操作称之为文件排序
  - Using temporary：表示MySQL在对查询结果排序时使用临时表，常用于排序 order by和分组查询 group by

#### 联合索引的最左匹配原则

#### 索引建立的越多越好吗

- 数据量小不需要
- 维护成本更高
- 更多的空间

### 锁

- 加共享锁（读锁）：SQL 末尾加上`lock in share mode`
- 加排它锁（写锁）：SQL 末尾加上`for update` 
- 关闭此次会话 session 自动提交的设定：`set autocommit = 0`
- **InnoDB**在 SQL 查询没有用到索引的时候，是表级锁，在用到索引的时候，才是行级锁，**MyISAM**是表级锁

#### MyISAM适合场景

- 频繁执行全表 count 语句
- 对数据的增删改的频率不高，查询非常频繁
- 没有事务

#### InnoDB

- 数据的增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

#### 数据库锁的分类

- 按粒度：表级锁，行级锁，页级锁
- 级别：共享锁，排它锁
- 加锁方式：自动锁，显式锁
- 操作：DML（数据操纵）锁，DDL（数据定义）锁
- 使用方式：乐观锁，悲观锁

### 事务（ACID）

- 原子性
- 一致性
- 隔离性
- 持久性

#### 事务并发访问

- 更新丢失，MySQL所有事务隔离级别在数据库层面均可避免
- 脏读：READ-COMMITTED事务隔离级别以上可以避免
- 不可重复读：REPEARABLE-READ 事务隔离级别以上可以避免
- 幻读：SERIALIZABLE事务隔离级别可以避免

#### InnoDB可重复读隔离级别下如何避免幻读

- 表象：快照读（非阻塞读）--伪MVCC
- 内在：next-key锁（行锁 + gap锁）

#### 对主键索引或者唯一索引会使用 Gap 锁吗？

- Gap 锁又称间隙锁，防止幻读

- 如果 where 条件全部命中，则不会用 Gap 锁，只会加记录锁
- 如果 where 条件不是全部命中，会用 Gap 锁

#### Gap 锁会用在非唯一索引或者不走索引的当前读中

#### 当前读和快照读取

- 当前读：select...lock in share mode, select...for update, update delete insert
- 快照读：不加锁的非阻塞读，select

#### RC（提交读）RR（可重复读）级别下的InnoDB的非阻塞读如何实现？

- 数据行的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段
- undo日志 
- read view

### 关键语法

#### GROUP BY

- 满足 "SELECT 子句中的列名必须是分组列或列函数"
- 列函数对应GROUP BY子句中定义的每个组各返回一个结果

#### HAVING

- 通常与 GROUP BY 子句一起使用
- WHERE 过滤行，HAVING 过滤列
- 出现在同一SQL的顺序：WHERE > GROUP BY > HAVING

## Redis

#### Memcache

- 支持简单数据类型
- 不支持数据持久化存储
- 不支持主从
- 不支持分片

#### Redis

- 数据类型丰富
- 支持数据持久化存储
- 支持主从
- 支持分片

#### Redis为什么这么快

- 完全基于内存，绝大部分请求是内存操作，执行效率高
- 数据结构简单，对数据操作简单
- 采用单线程，对单线程也能处理高并发请求，想多核也可启动多实例
- 使用多路I/O复用模型，非阻塞IO

#### Redis采用的I/O多路复用函数

- FD：file descriptor 文件描述符
- epoll/kqueue/evport/select
- 因地制宜
- 优先使用时间复杂度为o(1)的I/o多路复用函数作为底层实现
- 以时间复杂度为o(n)的select作为保底
- 基于react设计模式监听I/O事件

#### Redis数据类型

- String：最基本的数据类型，二进制安全，最大可保存512MB
- Hash：String元素组成的字典，适合用于存储对象
- List：列表，按照String元素插入顺序排序

- Set：String元素组成的无序集合，通过哈希表实现，不允许重复
- Sorted Set：通过分数来为集合中的成员进行从小到大的排序
- 计数：HyperLogLog，存储地理位置：Geo

#### 海量Key查询出某一固定前缀的Key

- 摸清数据规模

- KEYS pattern：查找所有符合给定模式pattern的key

  - 一次性返回所有匹配的key

  - 键的数量过大会使得服务卡顿

- SCAN course [MATCH pattern] [COUNT count]

  - 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
  - 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
  - 不保证每次执行都返回某个给定数量的元素，支持模糊查询
  - 一次返回的数量不可控，只能大概率 符合count参数

#### 分布式锁

- 互斥性
- 安全性
- 死锁
- 容错
- SETNX key value：如果key不存在，创建并赋值
  - 时间复杂度o(1)
  - 返回值：设置成功，返回1，设置失败，返回0
- EXPIRE key seconds
  - 设置key的生存时间，当key过期时，会被自动删除
- SET key value [EX seconds] [PX milliseconds] [NX|xx]
  - EX second：设置键的过期时间为second秒
  - PX millisecond：设置键的过期时间为millisecond 毫秒
  - NX：只有在键不存在的时候，才对键进行设置操作
  - SET操作完成，返回OK。否则返回nil

#### 大量KEY同时过期的注意事项

- 随机时间值

#### Redis实现异步队列

- 使用List作为队列，RPUSH生成消息，LPOP消费消息
- 缺点：没有等待队列里有值就直接消费
- 弥补：可以在应用层引入Sleep机制去调用LPOP重试
- BLPOP key [key] timeout：阻塞直到队列有消息或者超时
  - 缺点：只能供一个消费者消费
- pub/sub：主题订阅者模式
  - 发送者发送消息，订阅者接收消息
  - 订阅者可以订阅任意数量的频道
  - 消息的发布是无状态的，无法保证可达

#### Redis持久化

- RDB快照持久化，保存某个时间点的全量数据快照

  - 优点：全量数据快照，文件小，恢复快
  - 缺点：无法保存最近一次快照之后的数据

  - SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕
  - BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程
  - 全量同步会由于I/O而严重影响性能
  - 可能会因为Redis挂掉丢失从当前到最近一次快照时间的数据

- AOF持久化：保存写状态

  - 记录下除了查询以外的所有变更数据库状态的指令
  - 以append的形式追加保存到AOF文件中（增量）
  - 设置每一秒同步一次
  - 缺点：体积大，恢复时间长
  - 优点：可读性高，适合保存增量数据，数据不易丢失
  - 日志重写
    - 调用fork()，创建一个子进程
    - 子进程把新的aof写到临时文件，不依赖原来的AOF文件
    - 主进程持续将新的变动同时写到内存和原来的AOF
    - 主进程获取子进程重写AOF的完成信号，往新的AOF同步增量变动
    - 使用新的AOF文件替换掉旧的AOF文件

##### Redis数据恢复

- 先查看AOF，如果有直接恢复，没有再查看RDB

##### 4.0之后使用RDB-AOF混合持久化方式

- 使用BGSAVE做全量持久化，AOF做增量持久化

##### Copy-on-Write

如果有多个调用者同时要求相同资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源依然保持不变

#### Pipeline

- 与Linux管道类似
- 批量执行指令，节省多次IO往返时间
- 有顺序以来的指令建议分批发送

#### Redis同步机制

##### 全同步过程

- slave发送sync命令到master
- master启动一个后台进程，将redis的数据快照保存到文件中
- master将保存数据快照期间接收到的写命令缓存起来
- master完成写操作后，将该文件发送给slave
- 使用新的aof文件替换掉旧的aof文件
- master将这期间收集的增量写命令发送给slave

##### 增量同步过程

- master接受到用户的操作指令，判断是否需要传播到slave
- 将操作记录追加到aof文件
- 将操作传播到其他slave：1对齐主从库，2往响应缓存写入指令
- 将缓存中的数据发送给slave

#### Redis Sentinel

解决主从同步master宕机后的主从切换问题

- 监控：检测主从服务器是否正常运行
- 提醒：通过API向管理员或者其他应用程序发送故障通知
- 自动故障迁移：主从切换

#### 流言协议 Gossip

- 每个节点都随机地与对方进行通信，最终所有的节点状态达成一致
- 种子节点定期随机向其他节点发送节点列表以及需要传播的消息
- 不保证消息一定会传递给所有节点，但是最终会趋于一致

#### Redis集群原理

- 一致性哈希算法：对2的32次方取模，将哈希值空间组成虚拟的圆环
- 将数据key使用相同的函数hash计算出哈希值
- 引入服务器虚拟节点（一对多映射）解决数据倾斜，分布不均的问题

## Linux

http://www.cygwin.com/

#### 体系结构

- 分为用户态（用户上层活动）和内核态
- 内核：本质是一段管理计算机硬件设备的程序

- 系统调用：内核的访问接口，是一种不能再简化的操作
- 公用函数库，系统调用的组合拳 
- shell：命令解释器

#### 查找特定文件（find）

- 作用：在指定目录下查找文件
- `find ~ -name ”xxx“`  精确查找 ~表示查找目录
- `find ~ -name "xxx*"`  模糊查找
- `find ~ -iname "xxx*"`  忽略大小写模糊查找

#### 检索文件内容（grep）

- 管道操作符 | 可将指令链接起来，前一个指令的输出作为后一个指令的输入

#### 管道命令 |

- 只处理前一个命令正确输出，不处理错误输出
- 右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃
- sed awk grep cut head top less more wc join sort split

#### awk

- 一次读取一行文本，按输入分隔符进行切片，切成多个组成部分
- 将切片直接保存在内建的变量中，$1,$2...($0表示行的全部)
- 支持对单个切片的判断，支持循环判断，默认分隔符为空格

#### sed

- 全名 stream editor, 流编辑器
- 适合用于对文本的行内容进行处理

## JVM

#### 对java的理解

- 平台无关性
- GC
- 语言特性
- 面向对象
- 类库
- 异常处理

> javac 编译源码
>
> javap 查看字节码

#### 为什么jvm不直接将源码解析成机器码去执行？

- 准备工作：每次执行都需要各种检查
- 兼容性：也可以将别的语言解析成字节码，只要jvm支持的语言（Clojure、Groovy、JRuby、Jython、Scala）

#### jvm如何加载class文件

- class loader：依据特定格式，加载class文件到内存
- execution engine：对命令进行解析
- native interface：融合不同开发语言的原生库为java所用
- runtime data area：jvm内存空间结构模型

#### 反射

java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能被称java语言的反射机制

- Class.forName("全类名")
- getDeclareMethod
- getDeclareField

#### 类从编译到执行的过程

- 编译器将xxx.java源文件编译为xxx.class字节码文件
- class loader将字节码文件转换为jvm中的Class<xxx>对象
- jvm利用Class<XXX> 对象实例化为xxx对象

#### 谈谈class loader

class loader在java中有着非常重要的作用，它主要工作在class装载的加载阶段，其主要作用是从系统外部获取class 二进制数据流，它是java的核心组件，所有的class都是由classloader进行加载的，classloader负责将class文件中的二进制数据装载进系统，然后交给java虚拟机进行连接，初始化操作等等

#### ClassLoader种类

- BootStrapClassLoader：C++编写，加载核心库 java.*
- ExtClassLoader：Java编写，加载扩展类 javax.*
- AppClassLoader：Java编写，加载程序所在目录
- 自定义ClassLoader：Java编写，定制化加载

#### ClassLoader双亲委派

- 自下而上，从自定义ClassLoader->AppClassLoader->ExtClassLoader->BootStrapClassLoader去查找曾经是否加载过此类
- 如果都没有找到，那么从BootStrapClassLoader开始自上而下加载 JRE\lib\rt.jar或者Xbootclasspath选项指定的jar包

- 作用：避免多份同样字节码的加载

#### 类的加载方式

- 隐式加载：new
- 显示加载：loadClass，forName

#### 类的装载过程

1. 加载：通过ClassLoader加载字节码文件，生成class对象
2. 链接
   1. 检验：检查加载的的class的正确性与安全性
   2. 准备：为类变量分配存储空间并设置变量初始值
   3. 解析：jvm将常量池的符号引用转换为直接引用
3. 初始化：执行类变量赋值和静态代码块

#### loadClass和forName的区别

- Class.forName得到的class是已经完成初始化的
- Classloader.loadClass得到的class是还没有链接的
- Spring的延迟加载是用Classloader.loadClass，只有在使用的时候才会真正初始化

#### 你了解java内存模型吗？

- 线程私有：程序计数器，虚拟机栈，本地方法栈
- 线程共享：MetaSpace，Java堆

##### 程序计数器

- 当前线程所执行的字节码行号指示器（逻辑）
- 改变计数器的值来选取下一条需要执行的字节码指令
- 和线程是一对一的关系即 "线程私有"
- 对Java方法计数，如果是native方法则计数器值为underfined
- 不会发生内存泄漏

##### Java虚拟机栈（Srack）

- Java方法执行的内存模型
- 包含多个栈帧
- 局部变量表：包含方法执行过程中所有变量
- 操作数栈：入栈，出栈，复制，交换，产生消费变量

##### 本地方法栈

- 与虚拟机栈相似，主要作用于标注了native的方法

#### 递归为什么会引发`java.lang.StackOverflowError`异常

- 递归过深，栈帧数量超过虚拟机栈深度
- 也可能引发OOM

#### 元空间（MetaSpace）和永久代（PermGen）的区别

- 元空间使用本地内存，而永久代使用jvm内存
- jdk7将部分永久代数据转移到heap，jdk8永久移除永久代

#### MetaSpace相比PermGen的优势

- 字符串常量池存在永久代中，容易出现性能问题和内存溢出
- 类和方法的元信息大小难以确认，给永久代的大小指定带来困难
- 永久代会为GC带来不必要的复杂性
- 方便HotSpot与其他JVM如Jrockit的集成

#### Java堆（Heap）

- 对象实例的分配区域
- GC管理的主要区域

#### JVM三大性能调优参数 -Xms  -Xmx  -Xss

- -Xss：规定了每个线程虚拟机栈（堆栈）的大小，一般为256K，此参数影响此进程并发线程数的大小
- -Xms：堆的初始值
- -Xmx：堆能达到的最大值

#### Java内存模型中堆和栈的区别

- 内存分配策略
  - 静态存储：编译时确定每个数据目标在运行时的存储空间需求
  - 栈式存储：数据区需求在编译时未知，运行时模块入口前确定
  - 堆式存储：编译时或者运行时模块入口都无法确定，动态分配

- 联系：引用对象，数组时，栈内定义变量保存堆中目标的首地址
- 管理方式：栈自动释放，堆需要GC
- 空间大小：栈比堆小
- 碎片相关：栈产生的碎片远小于堆
- 分配方式：栈支持静态分配和动态分配，而堆仅支持动态分配
- 效率：栈的效率比堆高

#### 不同JDK版本之间的intern()方法的区别？jdk6 vs jdk6+

- jdk6：当调用intern()方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中该字符串的引用，否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用

- jdk6+：当调用intern()方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中该字符串的引用，否则，如果该字符串已经存在于java堆中，则将该对象的引用添加到字符串常量池，并且返回该引用，如果堆中不存在，则在池中创建该字符串并返回其引用

## Java垃圾回收

#### 对象被判定为垃圾的标准

- 没有被其他对象引用
- 方法
  - 引用计数算法
    - 判断对象的引用数量来决定对象是否可以被回收
    - 每个对象实例都有一个引用计数器，被引用则 +1, 完成引用则 -1
    - 任何引用计数为0的对象实例都可以被当做垃圾回收
    - 优点：执行效率高，程序执行受影响较小
    - 缺点：无法检测出循环引用的情况，导致内存泄漏
  - 可达性算法
    - 通过判断对象的引用链是否可达来决定对象是否可以被回收
  - 可以作为GC Root的对象
    - 虚拟机栈中引用的对象
    - 方法区中的常量引用的对象
    - 方法区类静态属性引用的对象
    - 本地方法栈JNI（Native方法）的引用对象
    - 活跃线程的引用对象

#### 垃圾回收算法

##### 标记清除算法

- 标记：从跟集合进行扫描，对存活的对象进行标记
- 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存
  - 缺点：产生大量不连续的内存碎片，如果后续需要分配大内存，可能会提前触发GC

##### 复制算法

- 分为对象面和空闲面
- 对象在对象面上创建
- 存活的对象被从对象面复制到空闲面
- 将对象面所有对象内存清除
- 优点
  - 解决了碎片化问题
  - 顺序分配内存，简单高效
  - 适用于对象存活率低的场景（年轻代）

#### 标记-整理算法

- 标记：从根节点进行扫描，对存活的对象进行标记
- 清除：移动所有存活的对象，且按照内存地址依次排列，然后将末端地址以后的内存全部回收
- 优点：
  - 避免内存的不连续
  - 不用设置两块内存互换
  - 适用于对象存活率高的场景（老年代）

#### 分代收集算法

- 垃圾回收算法的组合拳
- 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
- 目的：提高JVM的回收效率

##### 分类

- Minor GC
- Full Gc

**年轻代：尽可能快速收集掉那些生命周期短的对象**

- Eden区（大小占80%）
- 两个 Survivor区（大小各占10%）

##### 对象如何晋升到老年代

- 经历一定Minor次数依然存活的对象
- Survivor区中存放不下的对象
- 新生成的大对象（-XX: +PretenuerSizeThreshold）

##### 常用的调优参数

- -XX:SurvivorRatio：Eden和Survivor的比值，默认8:1
- -XX:NewRadio：老年代和年轻代大小的比例
- -XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值（默认15）

##### 老年代：存放生命周期较长的对象

- 新生代与老年代堆大小比例1:2

- 标记-清理算法
- 标记-整理算法
- Full GC 和 Major GC
- Full GC比Minor GC慢，效率低

##### 触发Full GC的条件

- 老年代空间不足
- 永久代空间不足（jdk7以下）
- CMS GC时出现promotion failed，concurrent mode failure

- Minor GC 晋升到老年代的平均大小大于老年代的剩余空间
- 调用System.gc()
- 使用RMI来管理RPC或管理的JDK应用，每小时执行一次Full GC

#### Stop-the-World

- JVM由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会发生
- 多数GC优化通过减少 Stop-the-World发生的时间来提高程序性能

#### Safepoint

- 分析过程中对象引用关系不会发生变化的点
- 发生Safepoint的地方：方法调用；循环跳转；异常跳转等
- 安全点数量得适中

#### JVM运行模式

- server
- client

#### 年轻代常见垃圾收集器

##### Serial

- -XX:+UseSerialGC，复制算法
- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模式下默认的年轻代收集器

##### ParNew

- -XX:+UseParNewGC，复制算法
- 多线程收集，其余的行为，特点和Serial收集器一样

- 多核下执行才有优势，单核心不如Serial效率高

##### Parallel Scavenge收集器

- -XX:+UseParallelGC，复制算法
- 比起关注用户线程停顿时间，更关注系统的吞吐量
- 在多核下执行才有优势，server模式下默认的年轻代收集器
- -XX:+UseAdaptiveSIzePolicy：内存调优由JVM控制管理

#### 老年代常见垃圾收集器

##### Serial Old收集器

- -XX:+UseSerialOldGC，标记-整理算法
- 简单高效，Client模式下默认的老年代收集器

##### Parallel Old收集器

- -XX:+UseParallelOldGC，标记-整理算法
- 多线程，吞吐量优先

##### CMS收集器

- -XX:+UseConcMarkSweepGC，标记-清除算法

- 初始标记：Stop-the-World
- 并发标记：并发追溯标记，程序不会停顿
- 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象
- 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象
- 并发清理：清理垃圾对象，程序不会停顿
- 并发重置：重置CMS收集器的数据结构

##### G1收集器

- -XX:+UseG1GC，复制+标记-整理算法
- 支持并发并行
- 分代收集
- 空间整合
- 可预测停顿
- 将整个Java堆内存划分成多个大小相等的Region
- 年轻代和老年代不再物理隔离

> JDK11

> Epsilon GC

> ZGC

#### GC面试题

##### Object的finalize方法的作用是否与C++的析构函数相同？

- 与C++的析构函数不同，析构函数调用确定，而它不确定
- 将未被引用的对象放置于F-Queue队列
- 方法执行随时可能被终止
- 给予对象最后一次重生的机会

##### Java中的强引用，软引用，弱引用，虚引用有什么用？

- 强引用
  - 最普遍的引用：Object obg = new Object()
  - 抛出 OutOfMemoryError终止程序也不会回收具有强引用的对象
  - 通过将对象设置为null来弱化引用，使其被回收

- 软引用（Soft Reference）
  - 对象处在有用但非必需的状态
  - 只有当空间不足的时候，GC会回收该引用的对象的内存
  - 可以用来实现高速缓存

- 弱引用（Week Reference）
  - 非必需的对象，比软引用更弱一些
  - GC时会被回收
  - 被回收的概率也不大，因为GC线程的优先级比较低
  - 适用于引用偶尔被使用且不影响收集的对象

- 虚引用（PhantomReference）
  - 不会决定对象的生命周期
  - 任何时候都可能被垃圾收集器回收
  - 跟踪对象被垃圾收集器回收的活动，起哨兵作用
  - 必须和引用队列ReferenceQueue联合使用
- 引用队列（ReferenceQueue）
  - 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达
  - 存储关联的且被GC的软引用，弱引用以及虚引用

## 多线程与并发

#### 进程与线程由来

1. 串行：初期计算机只能串行执行任务，并且需要长时间等待用户输入
2. 批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行
3. 进程：进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能
4. 线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务可以并发执行

#### 进程与线程区别

- 进程是资源分配的最小单元，线程是CPU调度的最小单元
  - 所有与进程相关的资源，都被记录在PCB（进程控制块）中
  - 进程是抢占处理机的调度单位；线程属于某个进程，共享其资源
  - 线程只由堆栈寄存器，程序计数器，TCB组成

- 线程不能看做独立应用，而进程可看做独立应用
- 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
- 线程没有独立的地址空间，多进程的程序比多线程的程序健壮
- 进程的切换比线程的切换开销大

#### Java中进程与线程区别

- Java对操作系统提供的功能进行封装，包括进程和线程
- 运行一个程序会产生一个进程，进程至少包含一个线程
- 每个进程对应一个JVM实例，多个线程共享JVM里的堆
- Java采用单线程编程模型，程序会自动创建主线程
- 主线程可以创建子线程，原则上，主线程要后于子线程完成执行

#### Thread和Runnable关系

- Thread是实现了Runnable接口的类，使的run支持多线程
- 因类的单一继承原则，推荐使用Runnable接口

#### 如何给run()传参

- 构造函数传参
- 成员变量传参
- 回调函数传参

#### 如何实现处理线程的返回值

- 主线程等待法
- 使用Thread类的join()阻塞当前线程以等待子线程处理完毕（即调用join()的一方先执行）
- 通过Callable接口实现：通过FutureTask Or线程池获取

#### 线程的状态

- 新建（New）：创建后尚未启动的线程的状态
- 运行（Runnable）：包含Running和Ready
- 无限期等待（Waiting）：不会被分配CPU执行时间，需要显式被唤醒
  - 没有设置timeout参数的Object.wait()方法
  - 没有设置timeout参数的Thread.join()方法
  - LockSupport.park()方法

- 限期等待（Time Waiting）：在一定时间后会被系统自动唤醒
  - Thread.sleep()方法
  - 设置了timeout参数的Object.wait()方法
  - 设置了timeout参数的Thread.join()方法
  - LockSupport.parkNanos()方法
  - LockSupport.parkUntil()方法
- 阻塞（Blockd）：等待获取排它锁
- 结束（Terminated）：已终止线程的状态，线程已经结束运行

#### sleep和wait

- sleep是Thread类的方法，wait是Object类中定义的方法
- sleep()方法可以在任何地方使用
- wait()方法只能在synchronized方法或synchronized块中使用
- Thread.sleep只会让出CPU，不会导致锁行为的改变
- Object.wait不仅让出CPU，还会释放已经占用的同步资源锁

#### notify和notifyAll区别

> JVM运行中的每个对象都具有两个池

##### 锁池 EntryList

假设线程A已经拥有了某个对象（不是类）的锁，而其他线程B、C线程在进入对象的synchronized方法（或者块）之前必须先获取该对象锁的拥有权，而恰巧该对象的锁目前正被线程A占用，所以B、C线程就会被阻塞，进入另一个地方去等待锁的释放，这个地方就是该对象的锁池

##### 等待池 WaitSet

假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池，进入到等待池中的线程不会去竞争该对象的锁

- notifyAll会让所有处于等待池的线程全部进入锁池去竞争锁的机会
- notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会

#### yield

- 当条用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但是线程调度器可能会忽略这个暗示

#### 如何中断线程

- 通过调用stop()方法**（已废弃）**
- 调用interrupt()，通知线程应该中断了

#### Synchronized

##### 线程安全问题的主要诱因

- 存在共享数据，也称临界资源
- 存在多条线程共同操作这些共享数据
- 解决办法：同一时刻有且仅有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作

##### 互斥锁

- 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块（复合操作）进行访问，互斥性也称为操作的原子性
- 可见性：必须确保在锁释放之前，对共享变量的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值）否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致

- Synchronized锁的不是代码，是对象

##### Synchronized锁分类

- 获取对象锁
  - 同步代码块（synchronized(this)，synchronized(类实例对象)）锁是小括号的实例对象
  - 同步非静态代码（synchronize method），锁是当前对象的实例方法

- 获取类锁
  - 同步代码块 (synchronized(类.class))，锁是小括号中的类对象
  - 同步静态方法(synchronized static method)，锁是当前对象的类对象

##### 总结

- 有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块
- 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞
- 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象的同步方法的线程会被阻塞
- 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步方法的线程会被阻塞
- 同一个类的不同对象的对象锁互不干扰
- 类锁由于也是一种特殊的对象锁，因此表现和上述一致，而由于一个类只有一把对象锁，所有同一个类的不同对象使用类锁将会是同步的
- 类锁和对象锁互不干扰

#### Synchronized底层

##### Monitor：每个Java对象都有的一把看不见的锁

##### 对象在内存中布局

- 对象头
  - Mark World：默认存储对象的hasCode，分代年龄，锁类型，锁标志位等信息
  - Class MetaData Address：类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的数据
- 实例数据
- 对齐填充

##### 什么是重入

- 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入
- synchronized支持重入

#### 为什么对Synchronized嗤之以鼻

- 早期版本中，Synchronized属于重量级锁，依赖于Mutex Lock实现
- 线程之间的切换需要从用户态切换到内核态，开销较大

#### Java6之后，性能得到较大提升

##### 自旋锁

何谓**自旋锁**？它是为实现保护[共享资源](https://baike.baidu.com/item/共享资源)而提出一种锁机制。其实，自旋锁与[互斥锁](https://baike.baidu.com/item/互斥锁)比较类似，它们都是为了解决对某项资源的互斥使用。无论是**[互斥锁](https://baike.baidu.com/item/互斥锁)**，还是**自旋锁**，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。

- 许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得
- 通过让线程执行忙循环等待锁的释放，不让出CPU
- 缺点：若锁被其他线程长时间占用，会带来许多性能上的开销

- PreBlockSpin：设置自旋次数

##### 自适应自旋锁

- 自旋的次数不再固定
- 由上一次在用一锁上的自旋时间及锁的拥有者的状态来决定

##### 锁消除

- JIT编译时候，对运行上下文进行扫描，去除不可能存在竞争的锁
- 例如方法内声明的 StringBuffer，JVM会自动消除锁

##### 锁粗化

- 扩大锁的加锁范围，避免重复加锁和解锁

##### Synchronized四种状态

- 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
- 膨胀方向：如上

##### 偏向锁：减少统一线程获取锁的代价

- 大部分情况下，锁不存在多线程竞争，总是由同一线程多次获取
- 如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word的结构也变为偏向锁结构，当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查Mark Word的锁标记位为偏向锁以及当前线程ID等于Mark Word的线程Id极客，这样就省去了大量有关锁申请的操作
- 不适合锁竞争比较激烈的多线程场合

##### 轻量级锁

- 轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争的时候，偏向锁就会升级为轻量级锁

- 适应的场景：线程交替执行同步块

- 若存在同一时间多线程访问同一锁的情况，会导致轻量级锁膨胀为重量级锁

##### 锁的内存语义

- 当线程释放锁时，java内存模型会把该线程对应的本地内存中的共享变量刷新到主内存
- 当线程获取锁的时候，java内存模型会把该线程对应的本地内存置为无效，从而使得监视器保护的临界区代码必须从主内存中读取共享变量

##### 总结

| 锁       | 优点                                                         | 缺点                                                         | 使用场景                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------ |
| 偏向锁   | 加锁和解锁不需要CAS操作，没有额外的性能消耗，和执行非同步方法相比仅存在纳秒的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗               | 只有一个线程访问同步块或者同步方法的场景         |
| 轻量级锁 | 竞争的线程不会阻塞，提高了响应速度                           | 若线程长时间抢不到锁，自旋会消耗CPU性能                      | 线程交替执行同步块或者同步方法的场景             |
| 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，响应时间缓慢，多线程下，频繁的获取释放锁，会带来巨大的性能消耗 | 追求吞吐量，同步块或者同步方法执行时间较长的场景 |

#### ReentrantLock与Synchronized区别

- 位于`java.util.concurrent.locks`
- 和CountDownLatch、FutureTask、Semaphore一样基于AQS实现
- 能够实现比SynchronizeD更细粒度的控制，如控制fairness
- 调用Lock()之后，必须调用unlock()释放锁
- 性能未必比Synchronized高，并且也是可重入的

##### ReentrantLock公平性的设置

- ReentrantLock fairLock = new ReentrantLock(true);
- 参数为tru时，倾向于将锁赋予等待时间最长的线程
- 公平锁：获取锁的顺序按先后调用lock方法的顺序（慎用）
- 非公平锁：抢占的顺序不一定，看运气
- Synchronized是非公平锁

##### ReentrantLock将锁对象化

- 判断是否有线程，或者某个特定线程，在排队等待获取锁
- 带超时的获取锁的尝试感知有没有成功获取锁

##### 是否能将wait/notify/notifyAll对象化

- `java.util.concurrent.locks.Condition`

##### 总结

- Synchronized是关键字，ReentrantLock是类
- ReentrantLock可以对获取锁的等待时间进行设置，避免死锁
- ReentrantLock可以获取各种锁的信息
- ReentrantLock可以灵活地实现多路通知
- 机制：Synchronized操作mark word，ReentrantLock调用Unsafe类的park()方法

#### Java内存模型JMM

本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式

##### 主内存

- 存储java实例对象
- 包括成员变量，类信息，常量，静态变量
- 属于数据共享的区域，多线程并发操作时会引发线程安全问题

##### 工作内存

- 存储当前方法的所有本地变量信息，本地变量对其他线程不可见
- 字节码行号指示器，Native方法信息
- 属于线程私有数据区域，不存在线程安全问题

##### 主内存和工作内存的数据存储类型以及操作方式归纳

- 方法中的基本数据类型、本地变量将直接存储在工作内存的栈帧结构
- 引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中
- 成员变量，static变量，类信息均会被存储到主内存中
- 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新回主内存

##### JMM如何解决可见性问题

**指令重排序需要满足的条件**

- 在单线程环境下不能改变程序运行的结果
- 存在数据依赖关系的不允许重排序
- 无法通过happens-before原则推导出来的，才能进行指令的重排序

**happens-before原则**

1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

##### Volatile如何禁止重排优化

- 内存屏障（Memory Barrier）
  - 保证特定操作的执行顺序
  - 保证某些变量的内存可见性
- 通过插入内存屏障指令禁止在内存屏障前后的指令执行重排序优化
- 强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本

##### Volatile和Synchronized区别

- Volatile本质是在告诉JVM当前变量在寄存器（工作变量）中的值是不确定的，需要从主存中读取；Synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止
- Volatile仅能使用在变量级别，Synchronized则可以使用在变量，方法和类级别
- Volatile仅能实现变量的修改可见性，不能保证原子性，而Synchronized则可以保证变量的修改的可见性和原子性
- Volatile不会造成线程的阻塞，Synchronized可能会造成线程的阻塞
- Volatile标记的变量不会被编译器优化，Synchronized标记的变量可以被编译器优化

#### CAS

- 一种高效实现线程安全性的方法
- 支持原子更新操作，适用于计数器，序列发生器等场景
- 属于乐观锁机制，号称lock-free
- CAS操作失败时由开发者决定是继续尝试还是执行别的操作
- JUC的atomic包提供了常用的原子性数据类型及其引用，数组等相关原子类型和更新操作工具，是很多线程安全程序的首选
- Unsafe类虽然提供CAS服务，但因能够操作任意内存地址读写而有隐患
- Java9以后，可以使用Variable Handle API来代替Unsafe

##### CAS思想

- CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

- 更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B
- V代表的是主内存的值，A代表的是工作内存的值

##### CAS缺点

- 若循环时间长，则开销很大(while尝试)
- 只能保证一个共享变量的原子操作
- ABA问题：解决：AtomicStampedReference

#### Java线程池

##### 指定工作线程数量的线程池子

- newFixedThreadPool(int nThreads)

##### 处理大量短时间工作任务的线程池

- newCachedThreadPool()
  - 试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程
  - 如果线程闲置的时间超过阈值，则会被终止并移除缓存
  - 系统长时间闲置的时候，不会消耗什么资源

##### 创建唯一的工作线程来执行任务，如果线程异常结束，会有另一个线程取代它

- newSingleThreadExecutor()

##### 定时或者周期性的工作调度

- newSingleThreadScheduledExecutor()
- newThreadScheduledExecutor(int corePoolSize)

内部会构建ForkJoinPool，利用working-stealing算法，并行处理任务，不保证处理顺序

- newWorkStealingPool()

##### JUC的三个Executor接口

- Executor：运行新任务的简单接口，将任务提交和任务执行细节解耦
- ExecutorService：具备管理执行器和任务生命周期的方法，提交任务机制更完善
- ScheduledExecutorService：支持Future和定期执行任务

##### ThreadPoolExecutor的构造函数

- corePoolSize：核心线程数量
- maxImumPoolSize：线程不够用时能够创建的最大线程数
- workQueue：任务等待队列
- keepAliveTime：抢占的顺序不一定，看运气
- threadFactory：创建新线程，默认Executors.defaultThreadFactory()

- handler：线程池的饱和策略
  - AbortPolicy：直接抛出异常，这是默认策略
  - CallRunsPolicy：用调用者所在的线程来执行任务
  - DiscardOldestPolicy：丢弃队列中最靠前的任务，并执行当前任务
  - DiscardPolicy：直接丢弃任务
  - 实现 RejectedExecutionHandler接口的自定义Handle

##### 新任务提交execute执行后的判断

- 如果运行的线程少于corePoolSize，则创建新线程来处理任务，即使线程池中的其他线程是空闲的
- 如果线程池中的线程数量大于等于corePoolSize且小于maxImumPoolSize，则只有当workQueue满时才创建新的线程去处理任务
- 如果设置的corePoolSize和maxImumPoolSize相同，则创建的线程池大小是固定的，如果有新任务提交，若workQueue未满，则将请求放入workQueue中，等待有空闲线程去从workQueue接任务并处理
- 如果运行的线程数量已经大于等于maxImunPoolSize，这时如果workQueue已经满了，则通过Handler所指定的策略来处理任务

##### 线程池的状态

- RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务
- SHUTDOWN：不再接受新提交的任务，但可以处理存量任务
  - RUNNING调用SHUTDOWN
- STOP：不再接受新提交的任务，也不处理存量任务
  - 调用SHUTDOWNNOW
- TIDYING：所有的任务都已终止
  - 工作线程数量为0时进入
- TERMINATED：terminated()方法执行完后进入该状态

##### 线程池的大小如何选定

- CPU密集型：线程数=核心数或者核心数+1
- I/O密集型：线程数=核心数*（1+平均等待时间）

##### Comparable和Comparator

Comparable表示可被排序的，实现该接口的类的对象自动拥有排序功能，实现方法：compareTo

Comparator则表示一个比较器，实现了该接口的的类的对象是一个针对目标类的对象定义的比较器，一般情况，这个比较器将作为一个参数进行传递，实现方法：compare

### HashMap

#### Java8如何对Hash算法和寻址算法的优化

##### Hash算法

```java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

- 原始HashCode：`1111 1111 1111 1111 1111 1010 0111 1100` 
- 右移16位（补0）：`0000 0000 0000 0000 1111 1111 1111 1111`

- 进行异或运算：`1111 1111 1111 1111 0000 0101 1000 0011`
- 转换为int值返回就是得到的Hash值了
- 对每个hash值，在低16位中，让高低16位进行了异或，让低16位同时保持了高低16位的特征，尽量避免一些 hash 值后续出现冲突

#####  寻址算法

- Java8之前：hash 值对数组长度取模，定位到数组的一个位置

- Java8之后：数组长度减去 1 与hash值进行与运算：`tab[index = (n - 1) & hash`
  - 取模运算性能比较差
  - 与运算性能较高
  - 二者效果一致

> 与运算：两位同时为 1，结果才为 1，否则为 0
>
> 或运算：两个对象，一个为1，其值为 1，否则为0
>
> 异或运算：两个值不相等则结果为 1，否则为 0

#### Hash Map如何解决 hash 碰撞问题

- Hash 运算之后还是有可能得到数组的同一个位置
- 数组位置存放了链表，不过链表长度过长会导致查询性能很差，极端情况：O(n)
- `TREEIFY_THRESHOLD` 默认为 8，超过之后链表会变为红黑树，时间复杂度：O(logn)

#### HashMap如何进行扩容

- 2倍扩容
- rehash

### Synchronized关键字

- **monitorenter**
- **monitorexit**