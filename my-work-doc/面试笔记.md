## 网络

## 数据库

### 索引

#### 结构

- 建立二叉查找树进行二分查找
- 建立 B-Tree 结构进行查找
- 建立 B+-Tree 结构进行查找
- 建立 Hash 结构进行查找

#### B-Tree

-  根节点至少包括2个孩子
- 树中每个节点最多含有 m 个孩子（m>=2）
- 除根节点和叶节点外，其他每个节点至少有 ceil(m/2)个孩子
- 所有叶子节点都位于同一层

#### B+Tree为什么更适合做存储索引

- 磁盘读写代价更低
- 查询效率更加稳定
- 更有利于对数据库的扫描

#### B+-Tree

B+树是B树的变体，其定义基本与B树相同

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针 P[i]，指向关键字值 [K[i], K[i+1]]的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子节点

#### Hash索引

缺点

- 仅仅满足 "=", "IN", 不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
- BitMap 位图索引

#### 密集索引与稀疏索引

- 密集索引文件中的每个搜索码值都对应一个索引值
- 稀疏索引文件只为索引码的某些值建立索引项
- InnoDB必须有且仅有一个密集索引
  - 若一个主键被定义，那么该主键作为密集索引
  - 若没有主键被定义，该表的第一个唯一非空索引作为密集索引
  - 若不满足以上条件，InnoDB内部会生成一个隐藏主键作为密集索引
  - 非主键索引存储相关键位和其对应的主键值，包含两次查询

#### 总结

- 为什么要使用索引
- 什么样的信息能成为索引
- 索引的数据结构
- 密集索引和稀疏索引的区别

#### 开启慢日志

```mysql
set global slow_query_log = on
set global long_query_time = 1
```

#### 开启SQL分析

- 在SQL语句前加 `explain`
- type：找到需要行的方式，index和all表示本次查询是全表扫描
- extra
  - Using filesort：表示MySQl对结果使用一个外部索引，而不是从表里按索引次序读到相关内容，可能在内存或者磁盘上进行排序，MySQL无法利用索引完成的排序操作称之为文件排序
  - Using temporary：表示MySQL在对查询结果排序时使用临时表，常用于排序 order by和分组查询 group by

#### 联合索引的最左匹配原则

#### 索引建立的越多越好吗

- 数据量小不需要
- 维护成本更高
- 更多的空间

### 锁

- 加共享锁（读锁）：SQL 末尾加上`lock in share mode`
- 加排它锁（写锁）：SQL 末尾加上`for update` 
- 关闭此次会话 session 自动提交的设定：`set autocommit = 0`
- **InnoDB**在 SQL 查询没有用到索引的时候，是表级锁，在用到索引的时候，才是行级锁，**MyISAM**是表级锁

#### MyISAM适合场景

- 频繁执行全表 count 语句
- 对数据的增删改的频率不高，查询非常频繁
- 没有事务

#### InnoDB

- 数据的增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

#### 数据库锁的分类

- 按粒度：表级锁，行级锁，页级锁
- 级别：共享锁，排它锁
- 加锁方式：自动锁，显式锁
- 操作：DML（数据操纵）锁，DDL（数据定义）锁
- 使用方式：乐观锁，悲观锁

### 事务（ACID）

- 原子性
- 一致性
- 隔离性
- 持久性

#### 事务并发访问

- 更新丢失，MySQL所有事务隔离级别在数据库层面均可避免
- 脏读：READ-COMMITTED事务隔离级别以上可以避免
- 不可重复读：REPEARABLE-READ 事务隔离级别以上可以避免
- 幻读：SERIALIZABLE事务隔离级别可以避免

#### InnoDB可重复读隔离级别下如何避免幻读

- 表象：快照读（非阻塞读）--伪MVCC
- 内在：next-key锁（行锁 + gap锁）

#### 对主键索引或者唯一索引会使用 Gap 锁吗？

- Gap 锁又称间隙锁，防止幻读

- 如果 where 条件全部命中，则不会用 Gap 锁，只会加记录锁
- 如果 where 条件不是全部命中，会用 Gap 锁

#### Gap 锁会用在非唯一索引或者不走索引的当前读中

#### 当前读和快照读取

- 当前读：select...lock in share mode, select...for update, update delete insert
- 快照读：不加锁的非阻塞读，select

#### RC（提交读）RR（可重复读）级别下的InnoDB的非阻塞读如何实现？

- 数据行的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段
- undo日志 
- read view

### 关键语法

#### GROUP BY

- 满足 "SELECT 子句中的列名必须是分组列或列函数"
- 列函数对应GROUP BY子句中定义的每个组各返回一个结果

#### HAVING

- 通常与 GROUP BY 子句一起使用
- WHERE 过滤行，HAVING 过滤列
- 出现在同一SQL的顺序：WHERE > GROUP BY > HAVING

## Redis

#### Memcache

- 支持简单数据类型
- 不支持数据持久化存储
- 不支持主从
- 不支持分片

#### Redis

- 数据类型丰富
- 支持数据持久化存储
- 支持主从
- 支持分片

#### Redis为什么这么快

- 完全基于内存，绝大部分请求是内存操作，执行效率高
- 数据结构简单，对数据操作简单
- 采用单线程，对单线程也能处理高并发请求，想多核也可启动多实例
- 使用多路I/O复用模型，非阻塞IO

#### Redis采用的I/O多路复用函数

- FD：file descriptor 文件描述符
- epoll/kqueue/evport/select
- 因地制宜
- 优先使用时间复杂度为o(1)的I/o多路复用函数作为底层实现
- 以时间复杂度为o(n)的select作为保底
- 基于react设计模式监听I/O事件

#### Redis数据类型

- String：最基本的数据类型，二进制安全，最大可保存512MB
- Hash：String元素组成的字典，适合用于存储对象
- List：列表，按照String元素插入顺序排序

- Set：String元素组成的无序集合，通过哈希表实现，不允许重复
- Sorted Set：通过分数来为集合中的成员进行从小到大的排序
- 计数：HyperLogLog，存储地理位置：Geo

#### 海量Key查询出某一固定前缀的Key

- 摸清数据规模

- KEYS pattern：查找所有符合给定模式pattern的key

  - 一次性返回所有匹配的key

  - 键的数量过大会使得服务卡顿

- SCAN course [MATCH pattern] [COUNT count]

  - 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
  - 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
  - 不保证每次执行都返回某个给定数量的元素，支持模糊查询
  - 一次返回的数量不可控，只能大概率 符合count参数

#### 分布式锁

- 互斥性
- 安全性
- 死锁
- 容错
- SETNX key value：如果key不存在，创建并赋值
  - 时间复杂度o(1)
  - 返回值：设置成功，返回1，设置失败，返回0
- EXPIRE key seconds
  - 设置key的生存时间，当key过期时，会被自动删除
- SET key value [EX seconds] [PX milliseconds] [NX|xx]
  - EX second：设置键的过期时间为second秒
  - PX millisecond：设置键的过期时间为millisecond 毫秒
  - NX：只有在键不存在的时候，才对键进行设置操作
  - SET操作完成，返回OK。否则返回nil

#### 大量KEY同时过期的注意事项

- 随机时间值

#### Redis实现异步队列

- 使用List作为队列，RPUSH生成消息，LPOP消费消息
- 缺点：没有等待队列里有值就直接消费
- 弥补：可以在应用层引入Sleep机制去调用LPOP重试
- BLPOP key [key] timeout：阻塞直到队列有消息或者超时
  - 缺点：只能供一个消费者消费
- pub/sub：主题订阅者模式
  - 发送者发送消息，订阅者接收消息
  - 订阅者可以订阅任意数量的频道
  - 消息的发布是无状态的，无法保证可达

#### Redis持久化

- RDB快照持久化，保存某个时间点的全量数据快照

  - 优点：全量数据快照，文件小，恢复快
  - 缺点：无法保存最近一次快照之后的数据

  - SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕
  - BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程
  - 全量同步会由于I/O而严重影响性能
  - 可能会因为Redis挂掉丢失从当前到最近一次快照时间的数据

- AOF持久化：保存写状态

  - 记录下除了查询以外的所有变更数据库状态的指令
  - 以append的形式追加保存到AOF文件中（增量）
  - 设置每一秒同步一次
  - 缺点：体积大，恢复时间长
  - 优点：可读性高，适合保存增量数据，数据不易丢失
  - 日志重写
    - 调用fork()，创建一个子进程
    - 子进程把新的aof写到临时文件，不依赖原来的AOF文件
    - 主进程持续将新的变动同时写到内存和原来的AOF
    - 主进程获取子进程重写AOF的完成信号，往新的AOF同步增量变动
    - 使用新的AOF文件替换掉旧的AOF文件

##### Redis数据恢复

- 先查看AOF，如果有直接恢复，没有再查看RDB

##### 4.0之后使用RDB-AOF混合持久化方式

- 使用BGSAVE做全量持久化，AOF做增量持久化

##### Copy-on-Write

如果有多个调用者同时要求相同资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源依然保持不变

#### Pipeline

- 与Linux管道类似
- 批量执行指令，节省多次IO往返时间
- 有顺序以来的指令建议分批发送

#### Redis同步机制

##### 全同步过程

- slave发送sync命令到master
- master启动一个后台进程，将redis的数据快照保存到文件中
- master将保存数据快照期间接收到的写命令缓存起来
- master完成写操作后，将该文件发送给slave
- 使用新的aof文件替换掉旧的aof文件
- master将这期间收集的增量写命令发送给slave

##### 增量同步过程

- master接受到用户的操作指令，判断是否需要传播到slave
- 将操作记录追加到aof文件
- 将操作传播到其他slave：1对齐主从库，2往响应缓存写入指令
- 将缓存中的数据发送给slave

#### Redis Sentinel

解决主从同步master宕机后的主从切换问题

- 监控：检测主从服务器是否正常运行
- 提醒：通过API向管理员或者其他应用程序发送故障通知
- 自动故障迁移：主从切换

#### 流言协议 Gossip

- 每个节点都随机地与对方进行通信，最终所有的节点状态达成一致
- 种子节点定期随机向其他节点发送节点列表以及需要传播的消息
- 不保证消息一定会传递给所有节点，但是最终会趋于一致

#### Redis集群原理

- 一致性哈希算法：对2的32次方取模，将哈希值空间组成虚拟的圆环
- 将数据key使用相同的函数hash计算出哈希值
- 引入服务器虚拟节点（一对多映射）解决数据倾斜，分布不均的问题

## Linux

http://www.cygwin.com/

#### 体系结构

- 分为用户态（用户上层活动）和内核态
- 内核：本质是一段管理计算机硬件设备的程序

- 系统调用：内核的访问接口，是一种不能再简化的操作
- 公用函数库，系统调用的组合拳 
- shell：命令解释器

#### 查找特定文件（find）

- 作用：在指定目录下查找文件
- `find ~ -name ”xxx“`  精确查找 ~表示查找目录
- `find ~ -name "xxx*"`  模糊查找
- `find ~ -iname "xxx*"`  忽略大小写模糊查找

#### 检索文件内容（grep）

- 管道操作符 | 可将指令链接起来，前一个指令的输出作为后一个指令的输入

#### 管道命令 |

- 只处理前一个命令正确输出，不处理错误输出
- 右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃
- sed awk grep cut head top less more wc join sort split

#### awk

- 一次读取一行文本，按输入分隔符进行切片，切成多个组成部分
- 将切片直接保存在内建的变量中，$1,$2...($0表示行的全部)
- 支持对单个切片的判断，支持循环判断，默认分隔符为空格

#### sed

- 全名 stream editor, 流编辑器
- 适合用于对文本的行内容进行处理

## JVM

#### 对java的理解

- 平台无关性
- GC
- 语言特性
- 面向对象
- 类库
- 异常处理

> javac 编译源码
>
> javap 查看字节码

#### 为什么jvm不直接将源码解析成机器码去执行？

- 准备工作：每次执行都需要各种检查
- 兼容性：也可以将别的语言解析成字节码，只要jvm支持的语言（Clojure、Groovy、JRuby、Jython、Scala）

#### jvm如何加载class文件

- class loader：依据特定格式，加载class文件到内存
- execution engine：对命令进行解析
- native interface：融合不同开发语言的原生库为java所用
- runtime data area：jvm内存空间结构模型

#### 反射

java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能被称java语言的反射机制

- Class.forName("全类名")
- getDeclareMethod
- getDeclareField

#### 类从编译到执行的过程

- 编译器将xxx.java源文件编译为xxx.class字节码文件
- class loader将字节码文件转换为jvm中的Class<xxx>对象
- jvm利用Class<XXX> 对象实例化为xxx对象

#### 谈谈class loader

class loader在java中有着非常重要的作用，它主要工作在class装载的加载阶段，其主要作用是从系统外部获取class 二进制数据流，它是java的核心组件，所有的class都是由classloader进行加载的，classloader负责将class文件中的二进制数据装载进系统，然后交给java虚拟机进行连接，初始化操作等等

#### ClassLoader种类

- BootStrapClassLoader：C++编写，加载核心库 java.*
- ExtClassLoader：Java编写，加载扩展类 javax.*
- AppClassLoader：Java编写，加载程序所在目录
- 自定义ClassLoader：Java编写，定制化加载

#### ClassLoader双亲委派

- 自下而上，从自定义ClassLoader->AppClassLoader->ExtClassLoader->BootStrapClassLoader去查找曾经是否加载过此类
- 如果都没有找到，那么从BootStrapClassLoader开始自上而下加载 JRE\lib\rt.jar或者Xbootclasspath选项指定的jar包

- 作用：避免多份同样字节码的加载

#### 类的加载方式

- 隐式加载：new
- 显示加载：loadClass，forName

#### 类的装载过程

1. 加载：通过ClassLoader加载字节码文件，生成class对象
2. 链接
   1. 检验：检查加载的的class的正确性与安全性
   2. 准备：为类变量分配存储空间并设置变量初始值
   3. 解析：jvm将常量池的符号引用转换为直接引用
3. 初始化：执行类变量赋值和静态代码块

#### loadClass和forName的区别

- Class.forName得到的class是已经完成初始化的
- Classloader.loadClass得到的class是还没有链接的
- Spring的延迟加载是用Classloader.loadClass，只有在使用的时候才会真正初始化

#### 你了解java内存模型吗？

- 线程私有：程序计数器，虚拟机栈，本地方法栈
- 线程共享：MetaSpace，Java堆

##### 程序计数器

- 当前线程所执行的字节码行号指示器（逻辑）
- 改变计数器的值来选取下一条需要执行的字节码指令
- 和线程是一对一的关系即 "线程私有"
- 对Java方法计数，如果是native方法则计数器值为underfined
- 不会发生内存泄漏

##### Java虚拟机栈（Srack）

- Java方法执行的内存模型
- 包含多个栈帧
- 局部变量表：包含方法执行过程中所有变量
- 操作数栈：入栈，出栈，复制，交换，产生消费变量

##### 本地方法栈

- 与虚拟机栈相似，主要作用于标注了native的方法

#### 递归为什么会引发`java.lang.StackOverflowError`异常

- 递归过深，栈帧数量超过虚拟机栈深度
- 也可能引发OOM

#### 元空间（MetaSpace）和永久代（PermGen）的区别

- 元空间使用本地内存，而永久代使用jvm内存
- jdk7将部分永久代数据转移到heap，jdk8永久移除永久代

#### MetaSpace相比PermGen的优势

- 字符串常量池存在永久代中，容易出现性能问题和内存溢出
- 类和方法的元信息大小难以确认，给永久代的大小指定带来困难
- 永久代会为GC带来不必要的复杂性
- 方便HotSpot与其他JVM如Jrockit的集成

#### Java堆（Heap）

- 对象实例的分配区域
- GC管理的主要区域

#### JVM三大性能调优参数 -Xms  -Xmx  -Xss

- -Xss：规定了每个线程虚拟机栈（堆栈）的大小，一般为256K，此参数影响此进程并发线程数的大小
- -Xms：堆的初始值
- -Xmx：堆能达到的最大值

#### Java内存模型中堆和栈的区别

- 内存分配策略
  - 静态存储：编译时确定每个数据目标在运行时的存储空间需求
  - 栈式存储：数据区需求在编译时未知，运行时模块入口前确定
  - 堆式存储：编译时或者运行时模块入口都无法确定，动态分配

- 联系：引用对象，数组时，栈内定义变量保存堆中目标的首地址
- 管理方式：栈自动释放，堆需要GC
- 空间大小：栈比堆小
- 碎片相关：栈产生的碎片远小于堆
- 分配方式：栈支持静态分配和动态分配，而堆仅支持动态分配
- 效率：栈的效率比堆高

#### 不同JDK版本之间的intern()方法的区别？jdk6 vs jdk6+

- jdk6：当调用intern()方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中该字符串的引用，否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用

- jdk6+：当调用intern()方法时，如果字符串常量池先前已经创建出该字符串对象，则返回池中该字符串的引用，否则，如果该字符串已经存在于java堆中，则将该对象的引用添加到字符串常量池，并且返回该引用，如果堆中不存在，则在池中创建该字符串并返回其引用

## Java垃圾回收

#### 对象被判定为垃圾的标准

- 没有被其他对象引用
- 方法
  - 引用计数算法
    - 判断对象的引用数量来决定对象是否可以被回收
    - 每个对象实例都有一个引用计数器，被引用则 +1, 完成引用则 -1
    - 任何引用计数为0的对象实例都可以被当做垃圾回收
    - 优点：执行效率高，程序执行受影响较小
    - 缺点：无法检测出循环引用的情况，导致内存泄漏
  - 可达性算法
    - 通过判断对象的引用链是否可达来决定对象是否可以被回收
  - 可以作为GC Root的对象
    - 虚拟机栈中引用的对象
    - 方法区中的常量引用的对象
    - 方法区类静态属性引用的对象
    - 本地方法栈JNI（Native方法）的引用对象
    - 活跃线程的引用对象

#### 垃圾回收算法

##### 标记清除算法

- 标记：从跟集合进行扫描，对存活的对象进行标记
- 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存
  - 缺点：产生大量不连续的内存碎片，如果后续需要分配大内存，可能会提前触发GC

##### 复制算法

- 分为对象面和空闲面
- 对象在对象面上创建
- 存活的对象被从对象面复制到空闲面
- 将对象面所有对象内存清除
- 优点
  - 解决了碎片化问题
  - 顺序分配内存，简单高效
  - 适用于对象存活率低的场景（年轻代）

#### 标记-整理算法

- 标记：从根节点进行扫描，对存活的对象进行标记
- 清除：移动所有存活的对象，且按照内存地址依次排列，然后将末端地址以后的内存全部回收
- 优点：
  - 避免内存的不连续
  - 不用设置两块内存互换
  - 适用于对象存活率高的场景（老年代）

#### 分代收集算法

- 垃圾回收算法的组合拳
- 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
- 目的：提高JVM的回收效率

##### 分类

- Minor GC
- Full Gc

**年轻代：尽可能快速收集掉那些生命周期短的对象**

- Eden区（大小占80%）
- 两个 Survivor区（大小各占10%）

##### 对象如何晋升到老年代

- 经历一定Minor次数依然存活的对象
- Survivor区中存放不下的对象
- 新生成的大对象（-XX: +PretenuerSizeThreshold）

##### 常用的调优参数

- -XX:SurvivorRatio：Eden和Survivor的比值，默认8:1
- -XX:NewRadio：老年代和年轻代大小的比例
- -XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经过GC次数的最大阈值（默认15）

##### 老年代：存放生命周期较长的对象

- 新生代与老年代堆大小比例1:2

- 标记-清理算法
- 标记-整理算法
- Full GC 和 Major GC
- Full GC比Minor GC慢，效率低

##### 触发Full GC的条件

- 老年代空间不足
- 永久代空间不足（jdk7以下）
- CMS GC时出现promotion failed，concurrent mode failure

- Minor GC 晋升到老年代的平均大小大于老年代的剩余空间
- 调用System.gc()
- 使用RMI来管理RPC或管理的JDK应用，每小时执行一次Full GC

#### Stop-the-World

- JVM由于要执行GC而停止了应用程序的执行
- 任何一种GC算法中都会发生
- 多数GC优化通过减少 Stop-the-World发生的时间来提高程序性能

#### Safepoint

- 分析过程中对象引用关系不会发生变化的点
- 发生Safepoint的地方：方法调用；循环跳转；异常跳转等
- 安全点数量得适中

#### JVM运行模式

- server
- client

#### 年轻代常见垃圾收集器

##### Serial

- -XX:+UseSerialGC，复制算法
- 单线程收集，进行垃圾收集时，必须暂停所有工作线程
- 简单高效，Client模式下默认的年轻代收集器

##### ParNew

- -XX:+UseParNewGC，复制算法
- 多线程收集，其余的行为，特点和Serial收集器一样

- 多核下执行才有优势，单核心不如Serial效率高

##### Parallel Scavenge收集器

- -XX:+UseParallelGC，复制算法
- 比起关注用户线程停顿时间，更关注系统的吞吐量
- 在多核下执行才有优势，server模式下默认的年轻代收集器
- -XX:+UseAdaptiveSIzePolicy：内存调优由JVM控制管理

#### 老年代常见垃圾收集器

##### Serial Old收集器

- -XX:+UseSerialOldGC，标记-整理算法
- 简单高效，Client模式下默认的老年代收集器

##### Parallel Old收集器

- -XX:+UseParallelOldGC，标记-整理算法
- 多线程，吞吐量优先

##### CMS收集器

- -XX:+UseConcMarkSweepGC，标记-清除算法

- 初始标记：Stop-the-World
- 并发标记：并发追溯标记，程序不会停顿
- 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象
- 重新标记：暂停虚拟机，扫描CMS堆中的剩余对象
- 并发清理：清理垃圾对象，程序不会停顿
- 并发重置：重置CMS收集器的数据结构

##### G1收集器

- -XX:+UseG1GC，复制+标记-整理算法
- 支持并发并行
- 分代收集
- 空间整合
- 可预测停顿
- 将整个Java堆内存划分成多个大小相等的Region
- 年轻代和老年代不再物理隔离

> JDK11

> Epsilon GC

> ZGC

#### GC面试题

##### Object的finalize方法的作用是否与C++的析构函数相同？

- 与C++的析构函数不同，析构函数调用确定，而它不确定
- 将未被引用的对象放置于F-Queue队列
- 方法执行随时可能被终止
- 给予对象最后一次重生的机会

##### Java中的强引用，软引用，弱引用，虚引用有什么用？

- 强引用
  - 最普遍的引用：Object obg = new Object()
  - 抛出 OutOfMemoryError终止程序也不会回收具有强引用的对象
  - 通过将对象设置为null来弱化引用，使其被回收

- 软引用（Soft Reference）
  - 对象处在有用但非必需的状态
  - 只有当空间不足的时候，GC会回收该引用的对象的内存
  - 可以用来实现高速缓存

- 弱引用（Week Reference）
  - 非必需的对象，比软引用更弱一些
  - GC时会被回收
  - 被回收的概率也不大，因为GC线程的优先级比较低
  - 适用于引用偶尔被使用且不影响收集的对象

- 虚引用（PhantomReference）
  - 不会决定对象的生命周期
  - 任何时候都可能被垃圾收集器回收
  - 跟踪对象被垃圾收集器回收的活动，起哨兵作用
  - 必须和引用队列ReferenceQueue联合使用
- 引用队列（ReferenceQueue）
  - 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达
  - 存储关联的且被GC的软引用，弱引用以及虚引用

## 多线程与并发

#### 进程与线程由来

1. 串行：初期计算机只能串行执行任务，并且需要长时间等待用户输入
2. 批处理：预先将用户的指令集中成清单，批量串行处理用户指令，仍然无法并发执行
3. 进程：进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并发处理任务提供了可能
4. 线程：共享进程的内存资源，相互间切换更快速，支持更细粒度的任务控制，使进程内的子任务可以并发执行

#### 进程与线程区别

- 进程是资源分配的最小单元，线程是CPU调度的最小单元
  - 所有与进程相关的资源，都被记录在PCB（进程控制块）中
  - 进程是抢占处理机的调度单位；线程属于某个进程，共享其资源
  - 线程只由堆栈寄存器，程序计数器，TCB组成

- 线程不能看做独立应用，而进程可看做独立应用
- 进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
- 线程没有独立的地址空间，多进程的程序比多线程的程序健壮
- 进程的切换比线程的切换开销大

#### Java中进程与线程区别

- Java对操作系统提供的功能进行封装，包括进程和线程
- 运行一个程序会产生一个进程，进程至少包含一个线程
- 每个进程对应一个JVM实例，多个线程共享JVM里的堆
- Java采用单线程编程模型，程序会自动创建主线程
- 主线程可以创建子线程，原则上，主线程要后于子线程完成执行

#### Thread和Runnable关系

- Thread是实现了Runnable接口的类，使的run支持多线程
- 因类的单一继承原则，推荐使用Runnable接口

#### 如何给run()传参

- 构造函数传参
- 成员变量传参
- 回调函数传参

#### 如何实现处理线程的返回值

- 主线程等待法
- 使用Thread类的join()阻塞当前线程以等待子线程处理完毕（即调用join()的一方先执行）
- 通过Callable接口实现：通过FutureTask Or线程池获取

#### 线程的状态

- 新建（New）：创建后尚未启动的线程的状态
- 运行（Runnable）：包含Running和Ready
- 无限期等待（Waiting）：不会被分配CPU执行时间，需要显式被唤醒
  - 没有设置timeout参数的Object.wait()方法
  - 没有设置timeout参数的Thread.join()方法
  - LockSupport.park()方法

- 限期等待（Time Waiting）：在一定时间后会被系统自动唤醒
  - Thread.sleep()方法
  - 设置了timeout参数的Object.wait()方法
  - 设置了timeout参数的Thread.join()方法
  - LockSupport.parkNanos()方法
  - LockSupport.parkUntil()方法
- 阻塞（Blockd）：等待获取排它锁
- 结束（Terminated）：已终止线程的状态，线程已经结束运行

#### sleep和wait

- sleep是Thread类的方法，wait是Object类中定义的方法
- sleep()方法可以在任何地方使用
- wait()方法只能在synchronized方法或synchronized块中使用
- Thread.sleep只会让出CPU，不会导致锁行为的改变
- Object.wait不仅让出CPU，还会释放已经占用的同步资源锁

#### notify和notifyAll区别

> JVM运行中的每个对象都具有两个池

##### 锁池 EntryList

假设线程A已经拥有了某个对象（不是类）的锁，而其他线程B、C线程在进入对象的synchronized方法（或者块）之前必须先获取该对象锁的拥有权，而恰巧该对象的锁目前正被线程A占用，所以B、C线程就会被阻塞，进入另一个地方去等待锁的释放，这个地方就是该对象的锁池

##### 等待池 WaitSet

假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池，进入到等待池中的线程不会去竞争该对象的锁

- notifyAll会让所有处于等待池的线程全部进入锁池去竞争锁的机会
- notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会