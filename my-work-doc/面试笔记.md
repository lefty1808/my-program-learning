## 网络

## 数据库

### 索引

#### 结构

- 建立二叉查找树进行二分查找
- 建立 B-Tree 结构进行查找
- 建立 B+-Tree 结构进行查找
- 建立 Hash 结构进行查找

#### B-Tree

-  根节点至少包括2个孩子
- 树中每个节点最多含有 m 个孩子（m>=2）
- 除根节点和叶节点外，其他每个节点至少有 ceil(m/2)个孩子
- 所有叶子节点都位于同一层

#### B+Tree为什么更适合做存储索引

- 磁盘读写代价更低
- 查询效率更加稳定
- 更有利于对数据库的扫描

#### B+-Tree

B+树是B树的变体，其定义基本与B树相同

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针 P[i]，指向关键字值 [K[i], K[i+1]]的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子节点

#### Hash索引

缺点

- 仅仅满足 "=", "IN", 不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高
- BitMap 位图索引

#### 密集索引与稀疏索引

- 密集索引文件中的每个搜索码值都对应一个索引值
- 稀疏索引文件只为索引码的某些值建立索引项
- InnoDB必须有且仅有一个密集索引
  - 若一个主键被定义，那么该主键作为密集索引
  - 若没有主键被定义，该表的第一个唯一非空索引作为密集索引
  - 若不满足以上条件，InnoDB内部会生成一个隐藏主键作为密集索引
  - 非主键索引存储相关键位和其对应的主键值，包含两次查询

#### 总结

- 为什么要使用索引
- 什么样的信息能成为索引
- 索引的数据结构
- 密集索引和稀疏索引的区别

#### 开启慢日志

```mysql
set global slow_query_log = on
set global long_query_time = 1
```

#### 开启SQL分析

- 在SQL语句前加 `explain`
- type：找到需要行的方式，index和all表示本次查询是全表扫描
- extra
  - Using filesort：表示MySQl对结果使用一个外部索引，而不是从表里按索引次序读到相关内容，可能在内存或者磁盘上进行排序，MySQL无法利用索引完成的排序操作称之为文件排序
  - Using temporary：表示MySQL在对查询结果排序时使用临时表，常用于排序 order by和分组查询 group by

#### 联合索引的最左匹配原则

#### 索引建立的越多越好吗

- 数据量小不需要
- 维护成本更高
- 更多的空间

### 锁

- 加共享锁（读锁）：SQL 末尾加上`lock in share mode`
- 加排它锁（写锁）：SQL 末尾加上`for update` 
- 关闭此次会话 session 自动提交的设定：`set autocommit = 0`
- **InnoDB**在 SQL 查询没有用到索引的时候，是表级锁，在用到索引的时候，才是行级锁，**MyISAM**是表级锁

#### MyISAM适合场景

- 频繁执行全表 count 语句
- 对数据的增删改的频率不高，查询非常频繁
- 没有事务

#### InnoDB

- 数据的增删改查都相当频繁
- 可靠性要求比较高，要求支持事务

#### 数据库锁的分类

- 按粒度：表级锁，行级锁，页级锁
- 级别：共享锁，排它锁
- 加锁方式：自动锁，显式锁
- 操作：DML（数据操纵）锁，DDL（数据定义）锁
- 使用方式：乐观锁，悲观锁

### 事务（ACID）

- 原子性
- 一致性
- 隔离性
- 持久性

#### 事务并发访问

- 更新丢失，MySQL所有事务隔离级别在数据库层面均可避免
- 脏读：READ-COMMITTED事务隔离级别以上可以避免
- 不可重复读：REPEARABLE-READ 事务隔离级别以上可以避免
- 幻读：SERIALIZABLE事务隔离级别可以避免

#### InnoDB可重复读隔离级别下如何避免幻读

- 表象：快照读（非阻塞读）--伪MVCC
- 内在：next-key锁（行锁 + gap锁）

#### 对主键索引或者唯一索引会使用 Gap 锁吗？

- Gap 锁又称间隙锁，防止幻读

- 如果 where 条件全部命中，则不会用 Gap 锁，只会加记录锁
- 如果 where 条件不是全部命中，会用 Gap 锁

#### Gap 锁会用在非唯一索引或者不走索引的当前读中

#### 当前读和快照读取

- 当前读：select...lock in share mode, select...for update, update delete insert
- 快照读：不加锁的非阻塞读，select

#### RC（提交读）RR（可重复读）级别下的InnoDB的非阻塞读如何实现？

- 数据行的DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID字段
- undo日志 
- read view

### 关键语法

#### GROUP BY

- 满足 "SELECT 子句中的列名必须是分组列或列函数"
- 列函数对应GROUP BY子句中定义的每个组各返回一个结果

#### HAVING

- 通常与 GROUP BY 子句一起使用
- WHERE 过滤行，HAVING 过滤列
- 出现在同一SQL的顺序：WHERE > GROUP BY > HAVING

## Redis

#### Memcache

- 支持简单数据类型
- 不支持数据持久化存储
- 不支持主从
- 不支持分片

#### Redis

- 数据类型丰富
- 支持数据持久化存储
- 支持主从
- 支持分片

#### Redis为什么这么快

- 完全基于内存，绝大部分请求是内存操作，执行效率高
- 数据结构简单，对数据操作简单
- 采用单线程，对单线程也能处理高并发请求，想多核也可启动多实例
- 使用多路I/O复用模型，非阻塞IO

#### Redis采用的I/O多路复用函数

- FD：file descriptor 文件描述符
- epoll/kqueue/evport/select
- 因地制宜
- 优先使用时间复杂度为o(1)的I/o多路复用函数作为底层实现
- 以时间复杂度为o(n)的select作为保底
- 基于react设计模式监听I/O事件

#### Redis数据类型

- String：最基本的数据类型，二进制安全，最大可保存512MB
- Hash：String元素组成的字典，适合用于存储对象
- List：列表，按照String元素插入顺序排序

- Set：String元素组成的无序集合，通过哈希表实现，不允许重复
- Sorted Set：通过分数来为集合中的成员进行从小到大的排序
- 计数：HyperLogLog，存储地理位置：Geo

#### 海量Key查询出某一固定前缀的Key

- 摸清数据规模

- KEYS pattern：查找所有符合给定模式pattern的key

  - 一次性返回所有匹配的key

  - 键的数量过大会使得服务卡顿

- SCAN course [MATCH pattern] [COUNT count]

  - 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
  - 以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历
  - 不保证每次执行都返回某个给定数量的元素，支持模糊查询
  - 一次返回的数量不可控，只能大概率 符合count参数

#### 分布式锁

- 互斥性
- 安全性
- 死锁
- 容错
- SETNX key value：如果key不存在，创建并赋值
  - 时间复杂度o(1)
  - 返回值：设置成功，返回1，设置失败，返回0
- EXPIRE key seconds
  - 设置key的生存时间，当key过期时，会被自动删除
- SET key value [EX seconds] [PX milliseconds] [NX|xx]
  - EX second：设置键的过期时间为second秒
  - PX millisecond：设置键的过期时间为millisecond 毫秒
  - NX：只有在键不存在的时候，才对键进行设置操作
  - SET操作完成，返回OK。否则返回nil

#### 大量KEY同时过期的注意事项

- 随机时间值

#### Redis实现异步队列

- 使用List作为队列，RPUSH生成消息，LPOP消费消息
- 缺点：没有等待队列里有值就直接消费
- 弥补：可以在应用层引入Sleep机制去调用LPOP重试
- BLPOP key [key] timeout：阻塞直到队列有消息或者超时
  - 缺点：只能供一个消费者消费
- pub/sub：主题订阅者模式
  - 发送者发送消息，订阅者接收消息
  - 订阅者可以订阅任意数量的频道
  - 消息的发布是无状态的，无法保证可达

#### Redis持久化

- RDB快照持久化，保存某个时间点的全量数据快照

  - 优点：全量数据快照，文件小，恢复快
  - 缺点：无法保存最近一次快照之后的数据

  - SAVE：阻塞Redis的服务器进程，直到RDB文件被创建完毕
  - BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程
  - 全量同步会由于I/O而严重影响性能
  - 可能会因为Redis挂掉丢失从当前到最近一次快照时间的数据

- AOF持久化：保存写状态

  - 记录下除了查询以外的所有变更数据库状态的指令
  - 以append的形式追加保存到AOF文件中（增量）
  - 设置每一秒同步一次
  - 缺点：体积大，恢复时间长
  - 优点：可读性高，适合保存增量数据，数据不易丢失
  - 日志重写
    - 调用fork()，创建一个子进程
    - 子进程把新的aof写到临时文件，不依赖原来的AOF文件
    - 主进程持续将新的变动同时写到内存和原来的AOF
    - 主进程获取子进程重写AOF的完成信号，往新的AOF同步增量变动
    - 使用新的AOF文件替换掉旧的AOF文件

##### Redis数据恢复

- 先查看AOF，如果有直接恢复，没有再查看RDB

##### 4.0之后使用RDB-AOF混合持久化方式

- 使用BGSAVE做全量持久化，AOF做增量持久化

##### Copy-on-Write

如果有多个调用者同时要求相同资源，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源依然保持不变

#### Pipeline

- 与Linux管道类似
- 批量执行指令，节省多次IO往返时间
- 有顺序以来的指令建议分批发送

#### Redis同步机制

##### 全同步过程

- slave发送sync命令到master
- master启动一个后台进程，将redis的数据快照保存到文件中
- master将保存数据快照期间接收到的写命令缓存起来
- master完成写操作后，将该文件发送给slave
- 使用新的aof文件替换掉旧的aof文件
- master将这期间收集的增量写命令发送给slave

##### 增量同步过程

- master接受到用户的操作指令，判断是否需要传播到slave
- 将操作记录追加到aof文件
- 将操作传播到其他slave：1对齐主从库，2往响应缓存写入指令
- 将缓存中的数据发送给slave

#### Redis Sentinel

解决主从同步master宕机后的主从切换问题

- 监控：检测主从服务器是否正常运行
- 提醒：通过API向管理员或者其他应用程序发送故障通知
- 自动故障迁移：主从切换

#### 流言协议 Gossip

- 每个节点都随机地与对方进行通信，最终所有的节点状态达成一致
- 种子节点定期随机向其他节点发送节点列表以及需要传播的消息
- 不保证消息一定会传递给所有节点，但是最终会趋于一致

#### Redis集群原理

- 一致性哈希算法：对2的32次方取模，将哈希值空间组成虚拟的圆环
- 将数据key使用相同的函数hash计算出哈希值
- 引入服务器虚拟节点（一对多映射）解决数据倾斜，分布不均的问题

## Linux

http://www.cygwin.com/

#### 体系结构

- 分为用户态（用户上层活动）和内核态
- 内核：本质是一段管理计算机硬件设备的程序

- 系统调用：内核的访问接口，是一种不能再简化的操作
- 公用函数库，系统调用的组合拳 
- shell：命令解释器

#### 查找特定文件（find）

- 作用：在指定目录下查找文件
- `find ~ -name ”xxx“`  精确查找 ~表示查找目录
- `find ~ -name "xxx*"`  模糊查找
- `find ~ -iname "xxx*"`  忽略大小写模糊查找

#### 检索文件内容（grep）

- 管道操作符 | 可将指令链接起来，前一个指令的输出作为后一个指令的输入

#### 管道命令 |

- 只处理前一个命令正确输出，不处理错误输出
- 右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃
- sed awk grep cut head top less more wc join sort split

#### awk

- 一次读取一行文本，按输入分隔符进行切片，切成多个组成部分
- 将切片直接保存在内建的变量中，$1,$2...($0表示行的全部)
- 支持对单个切片的判断，支持循环判断，默认分隔符为空格

#### sed

- 全名 stream editor, 流编辑器
- 适合用于对文本的行内容进行处理

## JVM

#### 对java的理解

- 平台无关性
- GC
- 语言特性
- 面向对象
- 类库
- 异常处理

> javac 编译源码
>
> javap 查看字节码

#### 为什么jvm不直接将源码解析成机器码去执行？

- 准备工作：每次执行都需要各种检查
- 兼容性：也可以将别的语言解析成字节码，只要jvm支持的语言（Clojure、Groovy、JRuby、Jython、Scala）

#### jvm如何加载class文件

- class loader：依据特定格式，加载class文件到内存
- execution engine：对命令进行解析
- native interface：融合不同开发语言的原生库为java所用
- runtime data area：jvm内存空间结构模型

#### 反射

java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意方法和属性，这种动态获取信息以及动态调用对象方法的功能被称java语言的反射机制

- Class.forName("全类名")
- getDeclareMethod
- getDeclareField

#### 类从编译到执行的过程

- 编译器将xxx.java源文件编译为xxx.class字节码文件
- class loader将字节码文件转换为jvm中的Class<xxx>对象
- jvm利用Class<XXX> 对象实例化为xxx对象

#### 谈谈class loader

class loader在java中有着非常重要的作用，它主要工作在class装载的加载阶段，其主要作用是从系统外部获取class 二进制数据流，它是java的核心组件，所有的class都是由classloader进行加载的，classloader负责将class文件中的二进制数据装载进系统，然后交给java虚拟机进行连接，初始化操作等等